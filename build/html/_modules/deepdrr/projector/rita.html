<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>deepdrr.projector.rita &mdash; DeepDRR 1.1.0a3 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/copybutton.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js?v=9d604193"></script>
        <script src="../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../_static/sphinx_highlight.js?v=4825356b"></script>
        <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            DeepDRR
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../deepdrr.html">deepdrr package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">DeepDRR</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">deepdrr.projector.rita</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for deepdrr.projector.rita</h1><div class="highlight"><pre>
<span></span><span class="c1">#</span>
<span class="c1"># Implementation of RITA algorithm as described in &#39;PENELOPE-2006: A Code System for Monte Carlo Simulation of Electron and Photon Transport&#39;</span>
<span class="c1">#</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Optional</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<div class="viewcode-block" id="RITA"><a class="viewcode-back" href="../../../deepdrr.projector.html#deepdrr.projector.rita.RITA">[docs]</a><span class="k">class</span> <span class="nc">RITA</span><span class="p">:</span>

    <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x_arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">y_arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">a_arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">b_arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a RITA object, which stores the tables of RITA parameters</span>

<span class="sd">        Args:</span>
<span class="sd">            x_arr (np.ndarray): the x_i&#39;s (grid points) for RITA</span>
<span class="sd">            y_arr (np.ndarray): the y_i&#39;s (Greek &#39;xi&#39; values) for RITA</span>
<span class="sd">            a_arr (np.ndarray): the a_i&#39;s for RITA</span>
<span class="sd">            b_arr (np.ndarray): the b_i&#39;s for RITA</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">x_arr</span><span class="o">.</span><span class="n">ndim</span>
        <span class="k">assert</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">y_arr</span><span class="o">.</span><span class="n">ndim</span>
        <span class="k">assert</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">a_arr</span><span class="o">.</span><span class="n">ndim</span>
        <span class="k">assert</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">b_arr</span><span class="o">.</span><span class="n">ndim</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_grid_points</span> <span class="o">=</span> <span class="n">x_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_grid_points</span> <span class="o">==</span> <span class="n">x_arr</span><span class="o">.</span><span class="n">size</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_grid_points</span> <span class="o">==</span> <span class="n">y_arr</span><span class="o">.</span><span class="n">size</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_grid_points</span> <span class="o">==</span> <span class="n">a_arr</span><span class="o">.</span><span class="n">size</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_grid_points</span> <span class="o">==</span> <span class="n">b_arr</span><span class="o">.</span><span class="n">size</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">x_arr</span> <span class="o">=</span> <span class="n">x_arr</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_arr</span> <span class="o">=</span> <span class="n">y_arr</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a_arr</span> <span class="o">=</span> <span class="n">a_arr</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b_arr</span> <span class="o">=</span> <span class="n">b_arr</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    
<div class="viewcode-block" id="RITA.from_saved_params"><a class="viewcode-back" href="../../../deepdrr.projector.html#deepdrr.projector.rita.RITA.from_saved_params">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_saved_params</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates and returns a RITA object based on the saved RITA parameters.</span>

<span class="sd">        Args:</span>
<span class="sd">            params (np.ndarray): the saved parameters.  See mcgpu_rita_samplers.py:saved_rita_params dictionary for available options</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">np_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">params</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">np_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">params</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">np_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">params</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">np_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">params</span><span class="p">[:,</span><span class="mi">3</span><span class="p">])</span>

        <span class="c1"># the saved RITA params should have 128 gridpoints</span>
        <span class="k">assert</span> <span class="mi">128</span> <span class="o">==</span> <span class="n">np_x</span><span class="o">.</span><span class="n">size</span>
        <span class="k">assert</span> <span class="mi">128</span> <span class="o">==</span> <span class="n">np_y</span><span class="o">.</span><span class="n">size</span>
        <span class="k">assert</span> <span class="mi">128</span> <span class="o">==</span> <span class="n">np_a</span><span class="o">.</span><span class="n">size</span>
        <span class="k">assert</span> <span class="mi">128</span> <span class="o">==</span> <span class="n">np_b</span><span class="o">.</span><span class="n">size</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">np_x</span><span class="p">,</span> <span class="n">np_y</span><span class="p">,</span> <span class="n">np_a</span><span class="p">,</span> <span class="n">np_b</span><span class="p">)</span></div>

<div class="viewcode-block" id="RITA.from_pdf"><a class="viewcode-back" href="../../../deepdrr.projector.html#deepdrr.projector.rita.RITA.from_pdf">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_pdf</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> 
        <span class="n">x_min</span><span class="p">:</span> <span class="n">dtype</span><span class="p">,</span>
        <span class="n">x_max</span><span class="p">:</span> <span class="n">dtype</span><span class="p">,</span>
        <span class="n">pdf_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">dtype</span><span class="p">],</span> <span class="n">dtype</span><span class="p">],</span>
        <span class="n">n_grid_points</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">]</span> <span class="o">=</span> <span class="mi">128</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates and returns a RITA object from the provided PDF over the provided interval, using the specified number of gridpoints.</span>

<span class="sd">        Args:</span>
<span class="sd">            x_min (np.float64): the lower bound of the interval to sample from</span>
<span class="sd">            x_max (np.float64): the upper bound of the interval to sample from</span>
<span class="sd">            pdf_func (Callable[[np.float64], np.float64]): the analytical PDF (float -&gt; float) of the function whose PDF we are sampling from</span>
<span class="sd">            n_grid_points (Optional[np.int32], optional): the number of grid points to finish with.  Must be at least 10.  Defaults to 128</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">cdf_func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">numerically_integrate</span><span class="p">(</span><span class="n">pdf_func</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">NUM_INITIAL_GRID_POINTS</span> <span class="o">=</span> <span class="mi">10</span>

        <span class="k">assert</span> <span class="n">NUM_INITIAL_GRID_POINTS</span> <span class="o">&lt;=</span> <span class="n">n_grid_points</span>
        
        <span class="c1"># Initial grid setup</span>
        <span class="n">delta_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_max</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">NUM_INITIAL_GRID_POINTS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># the initial size of the intervals</span>
        <span class="n">x_arr</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x_min</span> <span class="o">+</span> <span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">delta_x</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NUM_INITIAL_GRID_POINTS</span><span class="p">)]</span>
        <span class="n">y_arr</span> <span class="o">=</span> <span class="p">[</span><span class="n">cdf_func</span><span class="p">(</span><span class="n">x_arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NUM_INITIAL_GRID_POINTS</span><span class="p">)]</span>
        <span class="n">pdf_arr</span> <span class="o">=</span> <span class="p">[</span><span class="n">pdf_func</span><span class="p">(</span><span class="n">x_arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NUM_INITIAL_GRID_POINTS</span><span class="p">)]</span> <span class="c1"># not actually something that&#39;s returned. Just useful to store these values</span>
        <span class="n">a_arr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">b_arr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NUM_INITIAL_GRID_POINTS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_rita_calc_ab_for_idx</span><span class="p">(</span><span class="n">x_arr</span><span class="p">,</span> <span class="n">y_arr</span><span class="p">,</span> <span class="n">pdf_arr</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">a_arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">b_arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="n">a_arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">b_arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_arr</span><span class="p">)</span> <span class="o">==</span> <span class="n">NUM_INITIAL_GRID_POINTS</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_arr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_arr</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">a_arr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_arr</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">b_arr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">a_arr</span><span class="p">)</span>

        <span class="n">errors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NUM_INITIAL_GRID_POINTS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">epsilon</span> <span class="o">=</span> <span class="n">_rita_calc_interp_error</span><span class="p">(</span><span class="n">x_arr</span><span class="p">,</span> <span class="n">y_arr</span><span class="p">,</span> <span class="n">a_arr</span><span class="p">,</span> <span class="n">b_arr</span><span class="p">,</span> <span class="n">pdf_func</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">epsilon</span><span class="p">)</span>
        <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">errors</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_arr</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NUM_INITIAL_GRID_POINTS</span><span class="p">,</span> <span class="n">n_grid_points</span><span class="p">):</span> 
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">errors</span><span class="p">)</span> <span class="o">==</span> <span class="n">i</span>
            <span class="n">_rita_add_gridpoint</span><span class="p">(</span><span class="n">x_arr</span><span class="p">,</span> <span class="n">y_arr</span><span class="p">,</span> <span class="n">pdf_arr</span><span class="p">,</span> <span class="n">a_arr</span><span class="p">,</span> <span class="n">b_arr</span><span class="p">,</span> <span class="n">errors</span><span class="p">,</span> <span class="n">pdf_arr</span><span class="p">,</span> <span class="n">cdf_func</span><span class="p">)</span>
        
        <span class="k">assert</span> <span class="n">n_grid_points</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_arr</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">n_grid_points</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_arr</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">n_grid_points</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">a_arr</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">n_grid_points</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">b_arr</span><span class="p">)</span>

        <span class="n">np_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x_arr</span><span class="p">)</span>
        <span class="n">np_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y_arr</span><span class="p">)</span>
        <span class="n">np_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a_arr</span><span class="p">)</span>
        <span class="n">np_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">b_arr</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">np_x</span><span class="p">,</span> <span class="n">np_y</span><span class="p">,</span> <span class="n">np_a</span><span class="p">,</span> <span class="n">np_b</span><span class="p">)</span></div>

<div class="viewcode-block" id="RITA.sample_rita"><a class="viewcode-back" href="../../../deepdrr.projector.html#deepdrr.projector.rita.RITA.sample_rita">[docs]</a>    <span class="k">def</span> <span class="nf">sample_rita</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Using the provided RITA parameters, return an x-value based on the RITA-approximated PDF</span>

<span class="sd">        Args:</span>
<span class="sd">            x_arr (np.ndarray): the x_i&#39;s (grid points) for RITA</span>
<span class="sd">            y_arr (np.ndarray): the y_i&#39;s (Greek &#39;xi&#39; values) for RITA</span>
<span class="sd">            a_arr (np.ndarray): the a_i&#39;s for RITA</span>
<span class="sd">            b_arr (np.ndarray): the b_i&#39;s for RITA</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.float64: a randomly sampled x-value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="mi">1</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_arr</span><span class="o">.</span><span class="n">ndim</span>
        <span class="k">assert</span> <span class="mi">1</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_arr</span><span class="o">.</span><span class="n">ndim</span>
        <span class="k">assert</span> <span class="mi">1</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_arr</span><span class="o">.</span><span class="n">ndim</span>
        <span class="k">assert</span> <span class="mi">1</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_arr</span><span class="o">.</span><span class="n">ndim</span>

        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_grid_points</span>
        <span class="k">assert</span> <span class="n">N</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">N</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">N</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span> <span class="c1"># U[0,1]</span>

        <span class="c1"># Binary search to find the interval [y_i, y_{i+1}] that contains y</span>
        <span class="n">lo_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># inclusive</span>
        <span class="n">hi_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="c1"># exclusive</span>
        <span class="n">i</span> <span class="o">=</span> <span class="kc">None</span>            <span class="c1"># the index of the interval we find y in</span>
        <span class="k">while</span> <span class="n">lo_idx</span> <span class="o">&lt;</span> <span class="n">hi_idx</span><span class="p">:</span>
            <span class="n">mid_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor_divide</span><span class="p">(</span><span class="n">lo_idx</span> <span class="o">+</span> <span class="n">hi_idx</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

            <span class="c1"># Check if mid_idx is the lower bound of the correct interval</span>
            <span class="k">if</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_arr</span><span class="p">[</span><span class="n">mid_idx</span><span class="p">]:</span>
                <span class="c1"># Need to check lower intervals</span>
                <span class="n">hi_idx</span> <span class="o">=</span> <span class="n">mid_idx</span>
            <span class="k">elif</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_arr</span><span class="p">[</span><span class="n">mid_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="c1"># found correct interval</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">mid_idx</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Need to check higher intervals</span>
                <span class="n">lo_idx</span> <span class="o">=</span> <span class="n">mid_idx</span> <span class="o">+</span> <span class="mi">1</span>
        
        <span class="k">assert</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_arr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        
        <span class="n">nu</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">delta_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_arr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="n">delta_i_nu</span> <span class="o">=</span> <span class="n">delta_i</span> <span class="o">*</span> <span class="n">nu</span>
        <span class="n">numerator</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">delta_i_nu</span>
        <span class="n">denominator</span> <span class="o">=</span> <span class="p">(</span><span class="n">delta_i</span> <span class="o">*</span> <span class="n">delta_i</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">delta_i_nu</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">nu</span> <span class="o">*</span> <span class="n">nu</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_arr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span></div></div>

<span class="c1">#</span>
<span class="c1"># HELPER FUNCTIONS for RITA initialization</span>
<span class="c1">#</span>

<div class="viewcode-block" id="numerically_integrate"><a class="viewcode-back" href="../../../deepdrr.projector.html#deepdrr.projector.rita.numerically_integrate">[docs]</a><span class="k">def</span> <span class="nf">numerically_integrate</span><span class="p">(</span>
    <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
    <span class="n">x_min</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
    <span class="n">x_max</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Numerically integrates function &#39;func&#39; on the interval [x_min,x_max] using the 20-point Gauss method (see page 261 of &#39;PENELOPE-2006&#39;)</span>

<span class="sd">    Args:</span>
<span class="sd">        func (Callable[[np.float64], np.float64]): the function to integrate</span>
<span class="sd">        x_min (np.float64): the lower integration bound</span>
<span class="sd">        x_max (np.float64): the upper integration bound</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        np.float64: the result of numerically integrating &#39;func&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">abscissas</span> <span class="o">=</span> <span class="p">[</span>
        <span class="o">+</span><span class="mf">7.6526521133497334e-02</span><span class="p">,</span>
        <span class="o">-</span><span class="mf">7.6526521133497334e-02</span><span class="p">,</span>
        <span class="o">+</span><span class="mf">2.2778585114164508e-01</span><span class="p">,</span>
        <span class="o">-</span><span class="mf">2.2778585114164508e-01</span><span class="p">,</span>
        <span class="o">+</span><span class="mf">3.7370608871541956e-01</span><span class="p">,</span>
        <span class="o">-</span><span class="mf">3.7370608871541956e-01</span><span class="p">,</span>
        <span class="o">+</span><span class="mf">5.1086700195082710e-01</span><span class="p">,</span>
        <span class="o">-</span><span class="mf">5.1086700195082710e-01</span><span class="p">,</span>
        <span class="o">+</span><span class="mf">6.3605368072651503e-01</span><span class="p">,</span>
        <span class="o">-</span><span class="mf">6.3605368072651503e-01</span><span class="p">,</span>
        <span class="o">+</span><span class="mf">7.4633190646015079e-01</span><span class="p">,</span>
        <span class="o">-</span><span class="mf">7.4633190646015079e-01</span><span class="p">,</span>
        <span class="o">+</span><span class="mf">8.3911697182221882e-01</span><span class="p">,</span>
        <span class="o">-</span><span class="mf">8.3911697182221882e-01</span><span class="p">,</span>
        <span class="o">+</span><span class="mf">9.1223442825132591e-01</span><span class="p">,</span>
        <span class="o">-</span><span class="mf">9.1223442825132591e-01</span><span class="p">,</span>
        <span class="o">+</span><span class="mf">9.6397192727791379e-01</span><span class="p">,</span>
        <span class="o">-</span><span class="mf">9.6397192727791379e-01</span><span class="p">,</span>
        <span class="o">+</span><span class="mf">9.9312859918509492e-01</span>
        <span class="o">-</span><span class="mf">9.9312859918509492e-01</span>
    <span class="p">]</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="p">[</span>
        <span class="mf">1.5275338713072585e-01</span><span class="p">,</span>
        <span class="mf">1.5275338713072585e-01</span><span class="p">,</span>
        <span class="mf">1.4917298647260375e-01</span><span class="p">,</span>
        <span class="mf">1.4917298647260375e-01</span><span class="p">,</span>
        <span class="mf">1.4209610931838205e-01</span><span class="p">,</span>
        <span class="mf">1.4209610931838205e-01</span><span class="p">,</span>
        <span class="mf">1.3168863844917663e-01</span><span class="p">,</span>
        <span class="mf">1.3168863844917663e-01</span><span class="p">,</span>
        <span class="mf">1.1819453196151842e-01</span><span class="p">,</span>
        <span class="mf">1.1819453196151842e-01</span><span class="p">,</span>
        <span class="mf">1.0193011981724044e-01</span><span class="p">,</span>
        <span class="mf">1.0193011981724044e-01</span><span class="p">,</span>
        <span class="mf">8.3276741576704749e-02</span><span class="p">,</span>
        <span class="mf">8.3276741576704749e-02</span><span class="p">,</span>
        <span class="mf">6.2672048334109064e-02</span><span class="p">,</span>
        <span class="mf">6.2672048334109064e-02</span><span class="p">,</span>
        <span class="mf">4.0601429800386941e-02</span><span class="p">,</span>
        <span class="mf">4.0601429800386941e-02</span><span class="p">,</span>
        <span class="mf">1.7614007139152118e-02</span><span class="p">,</span>
        <span class="mf">1.7614007139152118e-02</span>
    <span class="p">]</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">abscissas</span><span class="p">)</span> <span class="o">==</span> <span class="mi">20</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">==</span> <span class="mi">20</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">abscissas</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">abscissas</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">assert</span> <span class="n">weights</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">weights</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

    <span class="n">avg</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_min</span> <span class="o">+</span> <span class="n">x_max</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_max</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">f_z_i</span> <span class="o">=</span> <span class="p">[</span><span class="n">func</span><span class="p">(</span><span class="n">diff</span> <span class="o">*</span> <span class="n">abscissas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">avg</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">abscissas</span><span class="p">))]</span>
    <span class="n">np_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">np_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f_z_i</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">diff</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np_w</span><span class="p">,</span> <span class="n">np_f</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">_rita_calc_ab_for_idx</span><span class="p">(</span>
    <span class="n">x_arr</span><span class="p">,</span>
    <span class="n">y_arr</span><span class="p">,</span>
    <span class="n">pdf_arr</span><span class="p">,</span>
    <span class="n">idx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the RITA parameters a_{idx} and b_{idx}, given the gridpoint arrays x_arr and y_arr</span>

<span class="sd">    Args:</span>
<span class="sd">        x_arr (raw Python array): the x-values for RITA</span>
<span class="sd">        y_arr (raw Python array): the y-values for RITA</span>
<span class="sd">        pdf_arr (raw Python array): the PDF we are sampling from, applied to element-wise to each item in x_arr</span>
<span class="sd">        idx (np.int32): the index in the gridpoint arrays of the interval we are concerned with: [x_{idx}, x_{idx+1})</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.float64: the RITA parameter a_{idx}</span>
<span class="sd">        np.float64: the RITA parameter b_{idx}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_arr</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_arr</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">x_arr</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_arr</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">*</span> <span class="n">tmp</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">pdf_arr</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">pdf_arr</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">/</span> <span class="n">pdf_arr</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="o">-</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>

<span class="k">def</span> <span class="nf">_rita_calc_interp_error</span><span class="p">(</span>
    <span class="n">x_arr</span><span class="p">,</span>
    <span class="n">y_arr</span><span class="p">,</span>
    <span class="n">a_arr</span><span class="p">,</span>
    <span class="n">b_arr</span><span class="p">,</span>
    <span class="n">pdf_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
    <span class="n">idx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the interpolation error \\epsilon_{idx}.  The formula for interpolation error is given in Eqn 1.57:</span>

<span class="sd">    \\epsilon_i = \\int_{x_i}^{x_{i+1}} |p(x) - \\widetilde{p}(x)| dx,</span>

<span class="sd">    where \\widetilde{p}(x) is defined by Eqns 1.55 and 1.56.  We compute this integral numerically.</span>

<span class="sd">    Args:</span>
<span class="sd">        x_arr (raw Python array): the x-values for RITA</span>
<span class="sd">        y_arr (raw Python array): the y-values for RITA</span>
<span class="sd">        a_arr (raw Python array): the &#39;a_i&#39; parameters for RITA</span>
<span class="sd">        b_arr (raw Python array): the &#39;b_i&#39; parameters for RITA</span>
<span class="sd">        pdf_func (Callable[[np.float64], np.float64]): the analytical PDF (float -&gt; float) of the function whose PDF we are sampling from</span>
<span class="sd">        idx (np.int32): the index of the interval we are calculating for</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x_i</span> <span class="o">=</span> <span class="n">a_arr</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
    <span class="n">a_i</span> <span class="o">=</span> <span class="n">a_arr</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
    <span class="n">b_i</span> <span class="o">=</span> <span class="n">b_arr</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

    <span class="n">interval</span> <span class="o">=</span> <span class="n">x_arr</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_i</span> <span class="c1"># the length of the interval</span>
    <span class="k">def</span> <span class="nf">calc_nu</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_i</span><span class="p">)</span> <span class="o">/</span> <span class="n">interval</span>
        <span class="n">big_term</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">a_i</span> <span class="o">+</span> <span class="n">b_i</span> <span class="o">-</span> <span class="p">(</span><span class="n">a_i</span> <span class="o">*</span> <span class="n">tau</span><span class="p">)</span>
        <span class="n">inside_sqrt_term</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">b_i</span> <span class="o">*</span> <span class="n">tau</span> <span class="o">*</span> <span class="n">tau</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">big_term</span> <span class="o">*</span> <span class="n">big_term</span><span class="p">)</span>
        <span class="n">right_factor</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">inside_sqrt_term</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">big_term</span> <span class="o">*</span> <span class="n">right_factor</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">b_i</span> <span class="o">*</span> <span class="n">tau</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">p_tilde</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">nu</span> <span class="o">=</span> <span class="n">calc_nu</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">b_nu2</span> <span class="o">=</span> <span class="n">b_i</span> <span class="o">*</span> <span class="n">nu</span> <span class="o">*</span> <span class="n">nu</span>
        <span class="n">partial_numer</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">a_i</span> <span class="o">*</span> <span class="n">nu</span><span class="p">)</span> <span class="o">+</span> <span class="n">b_nu2</span>
        <span class="n">numerator</span> <span class="o">=</span> <span class="p">(</span><span class="n">partial_numer</span> <span class="o">*</span> <span class="n">partial_numer</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y_arr</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_arr</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
        <span class="n">denominator</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a_i</span> <span class="o">+</span> <span class="n">b_i</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">b_nu2</span><span class="p">)</span> <span class="o">*</span> <span class="n">interval</span>
        <span class="k">return</span> <span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span>
    
    <span class="k">def</span> <span class="nf">integrand</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">pdf_func</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">p_tilde</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

    <span class="c1"># Using extended Simpson&#39;s rule with 51 points</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">interval</span> <span class="o">/</span> <span class="mi">50</span>
    <span class="n">odd_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">integrand</span><span class="p">(</span><span class="n">x_i</span> <span class="o">+</span> <span class="n">k</span> <span class="o">*</span> <span class="n">h</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span> <span class="c1"># 1, 3, ..., 49</span>
    <span class="n">even_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">integrand</span><span class="p">(</span><span class="n">x_i</span> <span class="o">+</span> <span class="n">k</span> <span class="o">*</span> <span class="n">h</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span> <span class="c1"># 2, 4, ..., 48</span>
    <span class="c1"># error_term = (h * h * h * h * h) * fourth_derivative(x_star) * 25 / 90 # don&#39;t actually need to figure out how to handle this</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">h</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">integrand</span><span class="p">(</span><span class="n">x_i</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">odd_sum</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">even_sum</span><span class="p">)</span> <span class="o">+</span> <span class="n">integrand</span><span class="p">(</span><span class="n">x_i</span> <span class="o">+</span> <span class="n">interval</span><span class="p">))</span> <span class="c1"># - error_term</span>

<span class="k">def</span> <span class="nf">_rita_add_gridpoint</span><span class="p">(</span>
    <span class="n">x_arr</span><span class="p">,</span>
    <span class="n">y_arr</span><span class="p">,</span>
    <span class="n">pdf_arr</span><span class="p">,</span>
    <span class="n">a_arr</span><span class="p">,</span>
    <span class="n">b_arr</span><span class="p">,</span>
    <span class="n">eps_arr</span><span class="p">,</span>
    <span class="n">pdf_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
    <span class="n">cdf_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Add a gridpoint for the RITA algorithm (within the interval with the currently-largest interpolation error)</span>

<span class="sd">    Args:</span>
<span class="sd">        x_arr (raw Python array): the x-values for RITA</span>
<span class="sd">        y_arr (raw Python array): the y-values for RITA</span>
<span class="sd">        pdf_arr (raw Python array): the PDF we are sampling from, applied to element-wise to each item in x_arr</span>
<span class="sd">        a_arr (raw Python array): the &#39;a_i&#39; parameters for RITA</span>
<span class="sd">        b_arr (raw Python array): the &#39;b_i&#39; parameters for RITA</span>
<span class="sd">        eps_arr (raw Python array): the interpolation errors for each interval</span>
<span class="sd">        pdf_func (Callable[[np.float64], np.float64]): the analytical PDF (float -&gt; float) of the function whose PDF we are sampling from</span>
<span class="sd">        cdf_func (Callable[[np.float64], np.float64]): the analytical CDF (float -&gt; float) of the function whose PDF we are sampling from</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        Upon return, data and parameters for a new gridpoint will have been placed in the arrays</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Find the interval with the largest interpolation error thus far</span>
    <span class="n">max_idx</span> <span class="o">=</span> <span class="n">eps_arr</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">eps_arr</span><span class="p">))</span>
    <span class="c1"># The interval [x_{max_idx}, x_{max_idx+1}] has the largest error</span>
    
    <span class="c1"># Split the interval with the largest interpolation error</span>
    <span class="n">x_j</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_arr</span><span class="p">[</span><span class="n">max_idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">x_arr</span><span class="p">[</span><span class="n">max_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="c1"># Emplace the new (x_j, y_j) gridpoint</span>
    <span class="n">x_arr</span>   <span class="o">=</span>   <span class="n">x_arr</span><span class="p">[:</span><span class="n">max_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span>         <span class="n">x_j</span> <span class="p">]</span> <span class="o">+</span>   <span class="n">x_arr</span><span class="p">[</span><span class="n">max_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
    <span class="n">y_arr</span>   <span class="o">=</span>   <span class="n">y_arr</span><span class="p">[:</span><span class="n">max_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">cdf_func</span><span class="p">(</span><span class="n">x_j</span><span class="p">)]</span> <span class="o">+</span>   <span class="n">y_arr</span><span class="p">[</span><span class="n">max_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
    <span class="n">pdf_arr</span> <span class="o">=</span> <span class="n">pdf_arr</span><span class="p">[:</span><span class="n">max_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">pdf_func</span><span class="p">(</span><span class="n">x_j</span><span class="p">)]</span> <span class="o">+</span> <span class="n">pdf_arr</span><span class="p">[</span><span class="n">max_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>

    <span class="c1"># Emplace the a_i and b_i for the upper of the two new intervals</span>
    <span class="c1"># (This corresponds to a_j and b_j, associated with x_j. j == max_idx+1)</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_rita_calc_ab_for_idx</span><span class="p">(</span><span class="n">x_arr</span><span class="p">,</span> <span class="n">y_arr</span><span class="p">,</span> <span class="n">pdf_arr</span><span class="p">,</span> <span class="n">max_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">a_arr</span> <span class="o">=</span> <span class="n">a_arr</span><span class="p">[:</span><span class="n">max_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">+</span> <span class="n">a_arr</span><span class="p">[</span><span class="n">max_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
    <span class="n">b_arr</span> <span class="o">=</span> <span class="n">b_arr</span><span class="p">[:</span><span class="n">max_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">+</span> <span class="n">b_arr</span><span class="p">[</span><span class="n">max_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>

    <span class="c1"># Replace (emphasis on the &#39;re-&#39;!) the a_i and b_i for the lower of the </span>
    <span class="c1"># two new intervals. (This corresponds to index max_idx)</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_rita_calc_ab_for_idx</span><span class="p">(</span><span class="n">x_arr</span><span class="p">,</span> <span class="n">y_arr</span><span class="p">,</span> <span class="n">pdf_arr</span><span class="p">,</span> <span class="n">max_idx</span><span class="p">)</span>
    <span class="n">a_arr</span><span class="p">[</span><span class="n">max_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
    <span class="n">b_arr</span><span class="p">[</span><span class="n">max_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>

    <span class="c1"># Emplace the interpolation error for the upper of the two new intervals</span>
    <span class="n">epsilon_j</span> <span class="o">=</span> <span class="n">_rita_calc_interp_error</span><span class="p">(</span><span class="n">x_arr</span><span class="p">,</span> <span class="n">y_arr</span><span class="p">,</span> <span class="n">a_arr</span><span class="p">,</span> <span class="n">b_arr</span><span class="p">,</span> <span class="n">pdf_func</span><span class="p">,</span> <span class="n">max_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">eps_arr</span> <span class="o">=</span> <span class="n">eps_arr</span><span class="p">[:</span><span class="n">max_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">epsilon_j</span><span class="p">]</span> <span class="o">+</span> <span class="n">eps_arr</span><span class="p">[</span><span class="n">max_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>

    <span class="c1"># Replace the interpolation error for the lower of the two new intervals</span>
    <span class="n">eps_arr</span><span class="p">[</span><span class="n">max_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">_rita_calc_interp_error</span><span class="p">(</span><span class="n">x_arr</span><span class="p">,</span> <span class="n">y_arr</span><span class="p">,</span> <span class="n">a_arr</span><span class="p">,</span> <span class="n">b_arr</span><span class="p">,</span> <span class="n">pdf_func</span><span class="p">,</span> <span class="n">max_idx</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Benjamin D. Killeen, Cong Gao, Jan-Nico Zaech, and Mathias Unberath.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>