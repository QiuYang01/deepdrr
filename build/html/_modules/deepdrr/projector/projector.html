<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>deepdrr.projector.projector &mdash; DeepDRR 1.1.0a3 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/copybutton.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js?v=9d604193"></script>
        <script src="../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../_static/sphinx_highlight.js?v=4825356b"></script>
        <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            DeepDRR
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../deepdrr.html">deepdrr package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">DeepDRR</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">deepdrr.projector.projector</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for deepdrr.projector.projector</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>


<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">geo</span><span class="p">,</span> <span class="n">utils</span><span class="p">,</span> <span class="n">vol</span>
<span class="kn">from</span> <span class="nn">..device</span> <span class="kn">import</span> <span class="n">Device</span><span class="p">,</span> <span class="n">MobileCArm</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">analytic_generators</span><span class="p">,</span> <span class="n">mass_attenuation</span><span class="p">,</span> <span class="n">scatter</span><span class="p">,</span> <span class="n">spectral_data</span>
<span class="kn">from</span> <span class="nn">.cuda_scatter_structs</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">CudaComptonStruct</span><span class="p">,</span>
    <span class="n">CudaMatMfpStruct</span><span class="p">,</span>
    <span class="n">CudaPlaneSurfaceStruct</span><span class="p">,</span>
    <span class="n">CudaRayleighStruct</span><span class="p">,</span>
    <span class="n">CudaWoodcockStruct</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.material_coefficients</span> <span class="kn">import</span> <span class="n">material_coefficients</span>
<span class="kn">from</span> <span class="nn">.mcgpu_compton_data</span> <span class="kn">import</span> <span class="n">COMPTON_DATA</span>
<span class="kn">from</span> <span class="nn">.mcgpu_mfp_data</span> <span class="kn">import</span> <span class="n">MFP_DATA</span>
<span class="kn">from</span> <span class="nn">.mcgpu_rita_samplers</span> <span class="kn">import</span> <span class="n">rita_samplers</span>

<span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">pycuda.autoprimaryctx</span>

    <span class="c1"># import pycuda.autoinit # causes problems when running with pytorch concurrently</span>
    <span class="kn">import</span> <span class="nn">pycuda.driver</span> <span class="k">as</span> <span class="nn">cuda</span>

    <span class="c1"># from pycuda.autoinit import context # also causes problems</span>
    <span class="kn">from</span> <span class="nn">pycuda.autoprimaryctx</span> <span class="kn">import</span> <span class="n">context</span>  <span class="c1"># retains context across multiple calls</span>
    <span class="kn">from</span> <span class="nn">pycuda.compiler</span> <span class="kn">import</span> <span class="n">SourceModule</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Running without pycuda: projector operations will fail.&quot;</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">RuntimeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Running without pycuda, possibly in subprocess: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="import_pycuda"><a class="viewcode-back" href="../../../deepdrr.projector.html#deepdrr.import_pycuda">[docs]</a><span class="k">def</span> <span class="nf">import_pycuda</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Import pycuda and return the context.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pycuda.autoinit.context: The pycuda context.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;pycuda&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">globals</span><span class="p">():</span>
        <span class="kn">import</span> <span class="nn">pycuda.autoprimaryctx</span>
        <span class="kn">import</span> <span class="nn">pycuda.driver</span> <span class="k">as</span> <span class="nn">cuda</span>
        <span class="kn">import</span> <span class="nn">pycuda.autoinit</span>
        <span class="kn">import</span> <span class="nn">pycuda.compiler</span></div>


<span class="n">NUMBYTES_INT8</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">NUMBYTES_INT32</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">NUMBYTES_FLOAT32</span> <span class="o">=</span> <span class="mi">4</span>


<span class="k">def</span> <span class="nf">_get_spectrum</span><span class="p">(</span><span class="n">spectrum</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">str</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the data corresponding to the given spectrum name.</span>

<span class="sd">    Args:</span>
<span class="sd">        spectrum (Union[np.ndarray, str]): the spectrum array or the spectrum itself.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If the spectrum is not recognized.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: The X-ray spectrum data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">spectrum</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">spectrum</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spectral_data</span><span class="o">.</span><span class="n">spectrums</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unrecognized spectrum: </span><span class="si">{</span><span class="n">spectrum</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">spectral_data</span><span class="o">.</span><span class="n">spectrums</span><span class="p">[</span><span class="n">spectrum</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unrecognized spectrum type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_kernel_projector_module</span><span class="p">(</span>
    <span class="n">num_volumes</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">num_materials</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">air_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">attenuate_outside_volume</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SourceModule</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compile the cuda code for the kernel projector.</span>

<span class="sd">    Assumes `project_kernel.cu`, `kernel_vol_seg_data.cu`, and `cubic` interpolation library is in the same directory as THIS</span>
<span class="sd">    file.</span>

<span class="sd">    Args:</span>
<span class="sd">        num_volumes (int): The number of volumes to assume</span>
<span class="sd">        num_materials (int): The number of materials to assume</span>

<span class="sd">    Returns:</span>
<span class="sd">        SourceModule: pycuda SourceModule object.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># path to files for cubic interpolation (folder cubic in DeepDRR)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span><span class="o">.</span><span class="n">parent</span>
    <span class="n">bicubic_path</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">d</span> <span class="o">/</span> <span class="s2">&quot;cubic&quot;</span><span class="p">)</span>
    <span class="n">source_path</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">d</span> <span class="o">/</span> <span class="s2">&quot;project_kernel.cu&quot;</span><span class="p">)</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">source_path</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
        <span class="n">source</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

    <span class="n">options</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;nt&quot;</span><span class="p">:</span>
        <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;running on windows is not thoroughly tested&quot;</span><span class="p">)</span>
        <span class="c1">#     options.append(&quot;--compiler-options&quot;)</span>
        <span class="c1">#     options.append(&#39;&quot;-D _WIN64&quot;&#39;)</span>

        <span class="c1"># options.append(&quot;-ccbin&quot;)</span>
        <span class="c1"># options.append(</span>
        <span class="c1">#     &#39;&quot;C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.32.31326\\bin\\Hostx64\\x64&quot;&#39;</span>
        <span class="c1"># )</span>

    <span class="n">options</span> <span class="o">+=</span> <span class="p">[</span>
        <span class="s2">&quot;-D&quot;</span><span class="p">,</span>
        <span class="sa">f</span><span class="s2">&quot;NUM_VOLUMES=</span><span class="si">{</span><span class="n">num_volumes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="s2">&quot;-D&quot;</span><span class="p">,</span>
        <span class="sa">f</span><span class="s2">&quot;NUM_MATERIALS=</span><span class="si">{</span><span class="n">num_materials</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="s2">&quot;-D&quot;</span><span class="p">,</span>
        <span class="sa">f</span><span class="s2">&quot;ATTENUATE_OUTSIDE_VOLUME=</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">attenuate_outside_volume</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="s2">&quot;-D&quot;</span><span class="p">,</span>
        <span class="sa">f</span><span class="s2">&quot;AIR_INDEX=</span><span class="si">{</span><span class="n">air_index</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;compiling </span><span class="si">{</span><span class="n">source_path</span><span class="si">}</span><span class="s2"> with NUM_VOLUMES=</span><span class="si">{</span><span class="n">num_volumes</span><span class="si">}</span><span class="s2">, NUM_MATERIALS=</span><span class="si">{</span><span class="n">num_materials</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">SourceModule</span><span class="p">(</span>
        <span class="n">source</span><span class="p">,</span>
        <span class="n">include_dirs</span><span class="o">=</span><span class="p">[</span><span class="n">bicubic_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">)],</span>
        <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">,</span>
        <span class="n">no_extern_c</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_kernel_scatter_module</span><span class="p">(</span><span class="n">num_materials</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SourceModule</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compile the cuda code for the scatter simulation.</span>

<span class="sd">    Assumes `scatter_kernel.cu` and `scatter_header.cu` are in the same directory as THIS file.</span>

<span class="sd">    Returns:</span>
<span class="sd">        SourceModule: pycuda SourceModule object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span><span class="o">.</span><span class="n">parent</span>
    <span class="n">source_path</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">d</span> <span class="o">/</span> <span class="s2">&quot;scatter_kernel.cu&quot;</span><span class="p">)</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">source_path</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
        <span class="n">source</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;compiling </span><span class="si">{</span><span class="n">source_path</span><span class="si">}</span><span class="s2"> with NUM_MATERIALS=</span><span class="si">{</span><span class="n">num_materials</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">SourceModule</span><span class="p">(</span>
        <span class="n">source</span><span class="p">,</span>
        <span class="n">include_dirs</span><span class="o">=</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">)],</span>
        <span class="n">no_extern_c</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">options</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;-D&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;NUM_MATERIALS=</span><span class="si">{</span><span class="n">num_materials</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">],</span>
    <span class="p">)</span>


<div class="viewcode-block" id="Projector"><a class="viewcode-back" href="../../../deepdrr.projector.html#deepdrr.Projector">[docs]</a><span class="k">class</span> <span class="nc">Projector</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">volumes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">vol</span><span class="o">.</span><span class="n">Volume</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">volume</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">vol</span><span class="o">.</span><span class="n">Volume</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">vol</span><span class="o">.</span><span class="n">Volume</span><span class="p">]],</span>
        <span class="n">priorities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">camera_intrinsics</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">geo</span><span class="o">.</span><span class="n">CameraIntrinsicTransform</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">step</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span>
        <span class="n">spectrum</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;90KV_AL40&quot;</span><span class="p">,</span>
        <span class="n">add_scatter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scatter_num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">add_noise</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">photon_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
        <span class="n">threads</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
        <span class="n">max_block_index</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">,</span>
        <span class="n">collected_energy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">neglog</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">intensity_upper_bound</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">attenuate_outside_volume</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">source_to_detector_distance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">carm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the projector, which has info for simulating the DRR.</span>

<span class="sd">        Usage:</span>
<span class="sd">        ```</span>
<span class="sd">        with Projector(volume, materials, ...) as projector:</span>
<span class="sd">            for projection in projections:</span>
<span class="sd">                yield projector(projection)</span>
<span class="sd">        ```</span>

<span class="sd">        Args:</span>
<span class="sd">            volume (Union[Volume, List[Volume]]): a volume object with materials segmented, or a list of volume objects.</span>
<span class="sd">            priorities (List[int], optional): Denotes the &#39;priority level&#39; of the volumes in projection by assigning an integer rank to each volume. At each position, volumes with lower rankings are sampled from as long</span>
<span class="sd">                                as they have a non-null segmentation at that location. Valid ranks are in the range [0, NUM_VOLUMES), with rank 0 having precedence over other ranks. Note that multiple volumes can share a</span>
<span class="sd">                                rank. If a list of ranks is provided, the ranks are associated in-order to the provided volumes.  If no list is provided (the default), the volumes are assumed to have distinct ranks, and</span>
<span class="sd">                                each volume has precedence over the preceding volumes. (This behavior is equivalent to passing in the list: [NUM_VOLUMES - 1, ..., 1, 0].)</span>
<span class="sd">            camera_intrinsics (CameraIntrinsicTransform): intrinsics of the projector&#39;s camera. (used for sensor size). If None, the CArm object must be provided and have a camera_intrinsics attribute. Defaults to None.</span>
<span class="sd">            device (Device, optional): Optional X-ray device object to use, which can provide a mapping from real C-arms to camera poses. If not provided, camera pose must be defined by user. Defaults to None.</span>
<span class="sd">            step (float, optional): size of the step along projection ray in voxels. Defaults to 0.1.</span>
<span class="sd">            mode (str): Interpolation mode for the kernel. Defaults to &quot;linear&quot;.</span>
<span class="sd">            spectrum (Union[np.ndarray, str], optional): Spectrum array or name of spectrum to use for projection. Options are `&#39;60KV_AL35&#39;`, `&#39;90KV_AL40&#39;`, and `&#39;120KV_AL43&#39;`. Defaults to &#39;90KV_AL40&#39;.</span>
<span class="sd">            add_scatter (bool, optional): Whether to add scatter noise from artifacts. This is deprecated in favor of `scatter_num`. Defaults to None.</span>
<span class="sd">            scatter_num (int, optional): the number of photons to sue in the scatter simulation.  If zero, scatter is not simulated.</span>
<span class="sd">            add_noise: (bool, optional): Whether to add Poisson noise. Defaults to False.</span>
<span class="sd">            photon_count (int, optional): the average number of photons that hit each pixel. (The expected number of photons that hit each pixel is not uniform over each pixel because the detector is a flat panel.) Defaults to 10^4.</span>
<span class="sd">            threads (int, optional): Number of threads to use. Defaults to 8.</span>
<span class="sd">            max_block_index (int, optional): Maximum GPU block. Defaults to 1024. TODO: determine from compute capability.</span>
<span class="sd">            collected_energy (bool, optional): Whether to return data of &quot;intensity&quot; (energy deposited per photon, [keV]) or &quot;collected energy&quot; (energy deposited on pixel, [keV / mm^2]). Defaults to False (&quot;intensity&quot;).</span>
<span class="sd">            neglog (bool, optional): whether to apply negative log transform to intensity images. If True, outputs are in range [0, 1]. Recommended for easy viewing. Defaults to False.</span>
<span class="sd">            intensity_upper_bound (float, optional): Maximum intensity, clipped before neglog, after noise and scatter. A good value is 40 keV / photon. Defaults to None.</span>
<span class="sd">            source_to_detector_distance (float, optional): If `device` is not provided, this is the distance from the source to the detector. This limits the lenght rays are traced for. Defaults to -1 (no limit).</span>
<span class="sd">            carm (MobileCArm, optional): Deprecated alias for `device`. See `device`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># set variables</span>
        <span class="n">volume</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">listify</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">volumes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">priorities</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_vol</span> <span class="ow">in</span> <span class="n">volume</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_vol</span><span class="p">,</span> <span class="n">vol</span><span class="o">.</span><span class="n">Volume</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_vol</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only up to 20 volumes are supported&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">priorities</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">priorities</span> <span class="o">=</span> <span class="p">[</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">))</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">prio</span> <span class="ow">in</span> <span class="n">priorities</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
                    <span class="n">prio</span><span class="p">,</span> <span class="nb">int</span>
                <span class="p">),</span> <span class="s2">&quot;missing priority, or priority is not an integer&quot;</span>
                <span class="k">assert</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">prio</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                    <span class="n">prio</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span>
                <span class="p">),</span> <span class="s2">&quot;invalid priority outside range [0, NUM_VOLUMES)&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">priorities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prio</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">priorities</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">carm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;carm is deprecated, use device instead&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">carm</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">device</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_camera_intrinsics</span> <span class="o">=</span> <span class="n">camera_intrinsics</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">step</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span> <span class="o">=</span> <span class="n">_get_spectrum</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_source_to_detector_distance</span> <span class="o">=</span> <span class="n">source_to_detector_distance</span>

        <span class="k">if</span> <span class="n">add_scatter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;add_scatter is deprecated. Set scatter_num instead.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">scatter_num</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only set scatter_num.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scatter_num</span> <span class="o">=</span> <span class="mf">1e7</span> <span class="k">if</span> <span class="n">add_scatter</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">scatter_num</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;scatter_num must be non-negative.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scatter_num</span> <span class="o">=</span> <span class="n">scatter_num</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scatter_num</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must provide device to simulate scatter.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_noise</span> <span class="o">=</span> <span class="n">add_noise</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">photon_count</span> <span class="o">=</span> <span class="n">photon_count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threads</span> <span class="o">=</span> <span class="n">threads</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_block_index</span> <span class="o">=</span> <span class="n">max_block_index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collected_energy</span> <span class="o">=</span> <span class="n">collected_energy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neglog</span> <span class="o">=</span> <span class="n">neglog</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intensity_upper_bound</span> <span class="o">=</span> <span class="n">intensity_upper_bound</span>
        <span class="c1"># TODO (mjudish): handle intensity_upper_bound when [collected_energy is True]</span>
        <span class="c1"># Might want to disallow using intensity_upper_bound, due to nonsensicalness</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="n">all_mats</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_vol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">:</span>
            <span class="n">all_mats</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">_vol</span><span class="o">.</span><span class="n">materials</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">all_materials</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">all_mats</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_materials</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;MATERIALS: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">all_materials</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">attenuate_outside_volume</span><span class="p">:</span>
            <span class="k">assert</span> <span class="s2">&quot;air&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_materials</span>
            <span class="n">air_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_materials</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;air&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">air_index</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># compile the module</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mod</span> <span class="o">=</span> <span class="n">_get_kernel_projector_module</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">),</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_materials</span><span class="p">),</span>
            <span class="n">air_index</span><span class="o">=</span><span class="n">air_index</span><span class="p">,</span>
            <span class="n">attenuate_outside_volume</span><span class="o">=</span><span class="n">attenuate_outside_volume</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">project_kernel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mod</span><span class="o">.</span><span class="n">get_function</span><span class="p">(</span><span class="s2">&quot;projectKernel&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scatter_num</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scatter_mod</span> <span class="o">=</span> <span class="n">_get_kernel_scatter_module</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_materials</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">simulate_scatter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scatter_mod</span><span class="o">.</span><span class="n">get_function</span><span class="p">(</span><span class="s2">&quot;simulate_scatter&quot;</span><span class="p">)</span>

            <span class="c1"># Calculate CUDA block parameters. Number of blocks is constant, each with</span>
            <span class="c1"># (self.threads * self.threads) threads, so that each block has same number</span>
            <span class="c1"># of threads as the projection kernel.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_scatter_blocks</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">32768</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_block_index</span><span class="p">)</span>
            <span class="c1"># TODO (mjudish): discuss with killeen max_block_index and what makes sense</span>
            <span class="c1"># for the scatter block structure</span>

            <span class="n">total_threads</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_scatter_blocks</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">threads</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">threads</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;total threads: </span><span class="si">{</span><span class="n">total_threads</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">histories_per_thread</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scatter_num</span> <span class="o">/</span> <span class="n">total_threads</span><span class="p">))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">scatter_num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">histories_per_thread</span> <span class="o">*</span> <span class="n">total_threads</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;input scatter_num: </span><span class="si">{</span><span class="n">scatter_num</span><span class="si">}</span><span class="s2">, rounded up to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">scatter_num</span><span class="si">}</span><span class="se">\n</span><span class="s2">histories per thread: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">histories_per_thread</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">resample_megavolume</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mod</span><span class="o">.</span><span class="n">get_function</span><span class="p">(</span><span class="s2">&quot;resample_megavolume&quot;</span><span class="p">)</span>

        <span class="c1"># assertions</span>
        <span class="k">for</span> <span class="n">mat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_materials</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">mat</span> <span class="ow">in</span> <span class="n">material_coefficients</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;unrecognized material: </span><span class="si">{</span><span class="n">mat</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="c1"># initialized when arrays are allocated.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">initialized</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source_to_detector_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="o">.</span><span class="n">source_to_detector_distance</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source_to_detector_distance</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">camera_intrinsics</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">geo</span><span class="o">.</span><span class="n">CameraIntrinsicTransform</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="o">.</span><span class="n">camera_intrinsics</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_camera_intrinsics</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_camera_intrinsics</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;No device provided. Set the device attribute by passing `device=&lt;device&gt;` to the constructor.&quot;</span>
            <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">volume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;projector contains multiple volumes. Access them with `projector.volumes[i]`&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">output_size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span><span class="p">))</span>

<div class="viewcode-block" id="Projector.project"><a class="viewcode-back" href="../../../deepdrr.projector.html#deepdrr.Projector.project">[docs]</a>    <span class="k">def</span> <span class="nf">project</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">camera_projections</span><span class="p">:</span> <span class="n">geo</span><span class="o">.</span><span class="n">CameraProjection</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform the projection.</span>

<span class="sd">        Args:</span>
<span class="sd">            camera_projection: any number of camera projections. If none are provided, the Projector uses the CArm device to obtain a camera projection.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: if no projections are provided and self.device is None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: array of DRRs, after mass attenuation, etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialized</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Projector has not been initialized.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">camera_projections</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;must provide a camera projection object to the projector, unless imaging device (e.g. CArm) is provided&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">camera_projections</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">camera_projections</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="o">.</span><span class="n">get_camera_projection</span><span class="p">()]</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;projecting with source at </span><span class="si">{</span><span class="n">camera_projections</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">center_in_world</span><span class="si">}</span><span class="s2">, pointing in </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="o">.</span><span class="n">principle_ray_in_world</span><span class="si">}</span><span class="s2">...&quot;</span>
            <span class="p">)</span>
            <span class="n">max_ray_length</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="o">.</span><span class="n">source_to_detector_distance</span><span class="o">**</span><span class="mi">2</span>
                <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="o">.</span><span class="n">detector_height</span><span class="o">**</span><span class="mi">2</span>
                <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="o">.</span><span class="n">detector_width</span><span class="o">**</span><span class="mi">2</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_ray_length</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Initiating projection and attenuation...&quot;</span><span class="p">)</span>

        <span class="n">project_tick</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>

        <span class="n">intensities</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">photon_probs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">proj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">camera_projections</span><span class="p">):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Projecting and attenuating camera position </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2"> / </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">camera_projections</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

            <span class="c1"># Only re-allocate if the output shape has changed.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initialize_output_arrays</span><span class="p">(</span><span class="n">proj</span><span class="o">.</span><span class="n">intrinsic</span><span class="o">.</span><span class="n">sensor_size</span><span class="p">)</span>

            <span class="c1"># Get the volume min/max points in world coordinates.</span>
            <span class="n">sx</span><span class="p">,</span> <span class="n">sy</span><span class="p">,</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">proj</span><span class="o">.</span><span class="n">get_center_in_world</span><span class="p">()</span>
            <span class="n">world_from_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">proj</span><span class="o">.</span><span class="n">world_from_index</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
            <span class="p">)</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">world_from_index_gpu</span><span class="p">,</span> <span class="n">world_from_index</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">_vol</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">):</span>
                <span class="n">source_ijk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="n">_vol</span><span class="o">.</span><span class="n">IJK_from_world</span> <span class="o">@</span> <span class="n">proj</span><span class="o">.</span><span class="n">center_in_world</span>
                <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod</span><span class="p">(</span>
                    <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sourceX_gpu</span><span class="p">)</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">NUMBYTES_INT32</span> <span class="o">*</span> <span class="n">vol_id</span><span class="p">),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">source_ijk</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span>
                <span class="p">)</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod</span><span class="p">(</span>
                    <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sourceY_gpu</span><span class="p">)</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">NUMBYTES_INT32</span> <span class="o">*</span> <span class="n">vol_id</span><span class="p">),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">source_ijk</span><span class="p">[</span><span class="mi">1</span><span class="p">]]),</span>
                <span class="p">)</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod</span><span class="p">(</span>
                    <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sourceZ_gpu</span><span class="p">)</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">NUMBYTES_INT32</span> <span class="o">*</span> <span class="n">vol_id</span><span class="p">),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">source_ijk</span><span class="p">[</span><span class="mi">2</span><span class="p">]]),</span>
                <span class="p">)</span>

                <span class="c1"># TODO: prefer toarray() to get transform throughout</span>
                <span class="n">IJK_from_world</span> <span class="o">=</span> <span class="n">_vol</span><span class="o">.</span><span class="n">IJK_from_world</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod</span><span class="p">(</span>
                    <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ijk_from_world_gpu</span><span class="p">)</span>
                    <span class="o">+</span> <span class="p">(</span><span class="n">IJK_from_world</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">NUMBYTES_FLOAT32</span><span class="p">)</span> <span class="o">*</span> <span class="n">vol_id</span><span class="p">,</span>
                    <span class="n">IJK_from_world</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="n">args</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">proj</span><span class="o">.</span><span class="n">sensor_width</span><span class="p">),</span>  <span class="c1"># out_width</span>
                <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">proj</span><span class="o">.</span><span class="n">sensor_height</span><span class="p">),</span>  <span class="c1"># out_height</span>
                <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">),</span>  <span class="c1"># step</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">priorities_gpu</span><span class="p">,</span>  <span class="c1"># priority</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">minPointX_gpu</span><span class="p">,</span>  <span class="c1"># gVolumeEdgeMinPointX</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">minPointY_gpu</span><span class="p">,</span>  <span class="c1"># gVolumeEdgeMinPointY</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">minPointZ_gpu</span><span class="p">,</span>  <span class="c1"># gVolumeEdgeMinPointZ</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">maxPointX_gpu</span><span class="p">,</span>  <span class="c1"># gVolumeEdgeMaxPointX</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">maxPointY_gpu</span><span class="p">,</span>  <span class="c1"># gVolumeEdgeMaxPointY</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">maxPointZ_gpu</span><span class="p">,</span>  <span class="c1"># gVolumeEdgeMaxPointZ</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">voxelSizeX_gpu</span><span class="p">,</span>  <span class="c1"># gVoxelElementSizeX</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">voxelSizeY_gpu</span><span class="p">,</span>  <span class="c1"># gVoxelElementSizeY</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">voxelSizeZ_gpu</span><span class="p">,</span>  <span class="c1"># gVoxelElementSizeZ</span>
                <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">sx</span><span class="p">),</span>  <span class="c1"># sx</span>
                <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">sy</span><span class="p">),</span>  <span class="c1"># sy</span>
                <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">sz</span><span class="p">),</span>  <span class="c1"># sz</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sourceX_gpu</span><span class="p">,</span>  <span class="c1"># sx_ijk</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sourceY_gpu</span><span class="p">,</span>  <span class="c1"># sy_ijk</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sourceZ_gpu</span><span class="p">,</span>  <span class="c1"># sz_ijk</span>
                <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">max_ray_length</span><span class="p">),</span>  <span class="c1"># max_ray_length</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">world_from_index_gpu</span><span class="p">,</span>  <span class="c1"># world_from_index</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ijk_from_world_gpu</span><span class="p">,</span>  <span class="c1"># ijk_from_world</span>
                <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>  <span class="c1"># n_bins</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">energies_gpu</span><span class="p">,</span>  <span class="c1"># energies</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pdf_gpu</span><span class="p">,</span>  <span class="c1"># pdf</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">absorption_coef_table_gpu</span><span class="p">,</span>  <span class="c1"># absorb_coef_table</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">intensity_gpu</span><span class="p">,</span>  <span class="c1"># intensity</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">photon_prob_gpu</span><span class="p">,</span>  <span class="c1"># photon_prob</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">solid_angle_gpu</span><span class="p">,</span>  <span class="c1"># solid_angle</span>
            <span class="p">]</span>

            <span class="c1"># Calculate required blocks</span>
            <span class="n">blocks_w</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">threads</span><span class="p">))</span>
            <span class="n">blocks_h</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">threads</span><span class="p">))</span>
            <span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">threads</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">threads</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Running: </span><span class="si">{</span><span class="n">blocks_w</span><span class="si">}</span><span class="s2">x</span><span class="si">{</span><span class="n">blocks_h</span><span class="si">}</span><span class="s2"> blocks with </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">threads</span><span class="si">}</span><span class="s2">x</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">threads</span><span class="si">}</span><span class="s2"> threads each&quot;</span>
            <span class="p">)</span>

            <span class="c1"># log.info(&quot;args: {}&quot;.format(&#39;\n&#39;.join(map(str, args))))</span>
            <span class="c1"># log.info(f&quot;offset_w: {offset_w}, offset_h: {offset_h}&quot;)</span>
            <span class="c1"># log.info(f&quot;block: {block}, grid: {(blocks_w, blocks_h)}&quot;)</span>
            <span class="k">if</span> <span class="n">blocks_w</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_block_index</span> <span class="ow">and</span> <span class="n">blocks_h</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_block_index</span><span class="p">:</span>
                <span class="n">offset_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">offset_h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">project_kernel</span><span class="p">(</span>
                    <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">offset_w</span><span class="p">,</span> <span class="n">offset_h</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="p">(</span><span class="n">blocks_w</span><span class="p">,</span> <span class="n">blocks_h</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Running kernel patchwise&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="n">blocks_w</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_block_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
                    <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="n">blocks_h</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_block_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
                        <span class="n">offset_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_block_index</span><span class="p">)</span>
                        <span class="n">offset_h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">h</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_block_index</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">project_kernel</span><span class="p">(</span>
                            <span class="o">*</span><span class="n">args</span><span class="p">,</span>
                            <span class="n">offset_w</span><span class="p">,</span>
                            <span class="n">offset_h</span><span class="p">,</span>
                            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
                            <span class="n">grid</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_block_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_block_index</span><span class="p">),</span>
                        <span class="p">)</span>
                        <span class="n">context</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>

            <span class="n">project_tock</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;projection #</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: time elapsed after call to project_kernel: </span><span class="si">{</span><span class="n">project_tock</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">project_tick</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

            <span class="n">intensity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_dtoh</span><span class="p">(</span><span class="n">intensity</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">intensity_gpu</span><span class="p">)</span>
            <span class="c1"># transpose the axes, which previously have width on the slow dimension</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;copied intensity from gpu&quot;</span><span class="p">)</span>
            <span class="n">intensity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">intensity</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;swapped intensity&quot;</span><span class="p">)</span>

            <span class="n">photon_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_dtoh</span><span class="p">(</span><span class="n">photon_prob</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">photon_prob_gpu</span><span class="p">)</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;copied photon_prob&quot;</span><span class="p">)</span>
            <span class="n">photon_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">photon_prob</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;swapped photon_prob&quot;</span><span class="p">)</span>

            <span class="n">project_tock</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;projection #</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: time elapased after copy from kernel: </span><span class="si">{</span><span class="n">project_tock</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">project_tick</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scatter_num</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;starting scatter&quot;</span><span class="p">)</span>
                <span class="c1"># TODO (mjudish): the resampled density never gets used in the scatter kernel</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Starting scatter simulation, scatter_num=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">scatter_num</span><span class="si">}</span><span class="s2">. Time: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">asctime</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

                <span class="c1"># index_from_ijk = (</span>
                <span class="c1">#    self.megavol_ijk_from_world @ proj.world_from_index</span>
                <span class="c1"># ).inv</span>
                <span class="c1"># index_from_ijk = np.array(index_from_ijk).astype(np.float32) # 2x4 matrix</span>
                <span class="c1"># print(f&quot;index_from_ijk on GPU:\n{index_from_ijk}&quot;)</span>
                <span class="c1"># cuda.memcpy_htod(self.index_from_ijk_gpu, index_from_ijk)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;index_from_world on GPU:</span><span class="se">\n</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">proj</span><span class="o">.</span><span class="n">index_from_world</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">index_from_world_gpu</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">proj</span><span class="o">.</span><span class="n">index_from_world</span><span class="p">)</span>
                <span class="p">)</span>

                <span class="n">scatter_source_ijk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">megavol_ijk_from_world</span> <span class="o">@</span> <span class="n">proj</span><span class="o">.</span><span class="n">center_in_world</span>
                <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;np.array(self.megavol_ijk_from_world) dims:</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">megavol_ijk_from_world</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">megavol_ijk_from_world</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;world_from_index:</span><span class="se">\n</span><span class="si">{</span><span class="n">world_from_index</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="n">scatter_source_world</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">proj</span><span class="o">.</span><span class="n">center_in_world</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

                <span class="n">detector_plane</span> <span class="o">=</span> <span class="n">scatter</span><span class="o">.</span><span class="n">get_detector_plane</span><span class="p">(</span>
                    <span class="c1"># np.array(self.megavol_ijk_from_world @ proj.world_from_index),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">proj</span><span class="o">.</span><span class="n">world_from_index</span><span class="p">),</span>
                    <span class="n">proj</span><span class="o">.</span><span class="n">index_from_camera2d</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">source_to_detector_distance</span><span class="p">,</span>
                    <span class="n">geo</span><span class="o">.</span><span class="n">Point3D</span><span class="o">.</span><span class="n">from_any</span><span class="p">(</span><span class="n">scatter_source_world</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">detector_plane_struct</span> <span class="o">=</span> <span class="n">CudaPlaneSurfaceStruct</span><span class="p">(</span>
                    <span class="n">detector_plane</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">detector_plane_gpu</span><span class="p">)</span>
                <span class="p">)</span>

                <span class="c1"># print the detector&#39;s corners in IJK</span>
                <span class="n">_tmp_corners_idx</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">]),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">]),</span>
                <span class="p">]</span>
                <span class="n">_tmp_corner_rays_world</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">proj</span><span class="o">.</span><span class="n">world_from_index</span> <span class="o">@</span> <span class="n">corner</span> <span class="k">for</span> <span class="n">corner</span> <span class="ow">in</span> <span class="n">_tmp_corners_idx</span>
                <span class="p">]</span>

                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Detector corner rays in world: (0,0), (W,0), (W,H), (0, H):&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">_corner_ray</span> <span class="ow">in</span> <span class="n">_tmp_corner_rays_world</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="si">{</span><span class="n">_corner_ray</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="c1"># end print corners</span>

                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;source in world:</span><span class="se">\n\t</span><span class="si">{</span><span class="n">proj</span><span class="o">.</span><span class="n">center_in_world</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">detector_ctr_in_world</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">detector_plane</span><span class="o">.</span><span class="n">surface_origin</span>
                    <span class="o">+</span> <span class="p">(</span><span class="n">detector_plane</span><span class="o">.</span><span class="n">basis_1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>
                    <span class="o">+</span> <span class="p">(</span><span class="n">detector_plane</span><span class="o">.</span><span class="n">basis_2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;detector center in world:</span><span class="se">\n\t</span><span class="si">{</span><span class="n">detector_ctr_in_world</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Detector corners in world, FROM RAYS:&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">_corner_ray</span> <span class="ow">in</span> <span class="n">_tmp_corner_rays_world</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="si">{</span><span class="n">proj</span><span class="o">.</span><span class="n">center_in_world</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">source_to_detector_distance</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">_corner_ray</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Detector corners in world, FROM PLANE_SURFACE:&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">_tmp_corners_idx</span><span class="p">:</span>
                    <span class="n">corner</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">detector_plane</span><span class="o">.</span><span class="n">surface_origin</span>
                        <span class="o">+</span> <span class="p">(</span><span class="n">detector_plane</span><span class="o">.</span><span class="n">basis_1</span> <span class="o">*</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="o">+</span> <span class="p">(</span><span class="n">detector_plane</span><span class="o">.</span><span class="n">basis_2</span> <span class="o">*</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="si">{</span><span class="n">corner</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="n">world_from_ijk_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">megavol_ijk_from_world</span><span class="o">.</span><span class="n">inv</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">world_from_ijk_gpu</span><span class="p">,</span> <span class="n">world_from_ijk_arr</span><span class="p">)</span>
                <span class="c1"># print(f&quot;world_from_ijk_arr:\n{world_from_ijk_arr}&quot;)</span>

                <span class="n">ijk_from_world_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">megavol_ijk_from_world</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ijk_from_world_gpu</span><span class="p">,</span> <span class="n">ijk_from_world_arr</span><span class="p">)</span>
                <span class="c1"># print(f&quot;ijk_from_world_arr:\n{ijk_from_world_arr}&quot;)</span>

                <span class="n">E_abs_keV</span> <span class="o">=</span> <span class="mi">5</span>  <span class="c1"># E_abs == 5000 eV</span>

                <span class="n">scatter_args</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">proj</span><span class="o">.</span><span class="n">sensor_width</span><span class="p">),</span>  <span class="c1"># detector_width</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">proj</span><span class="o">.</span><span class="n">sensor_height</span><span class="p">),</span>  <span class="c1"># detector_height</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">histories_per_thread</span><span class="p">),</span>  <span class="c1"># histories_for_thread</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">megavol_labeled_seg_gpu</span><span class="p">,</span>  <span class="c1"># labeled_segmentation</span>
                    <span class="n">scatter_source_ijk</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>  <span class="c1"># sx</span>
                    <span class="n">scatter_source_ijk</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>  <span class="c1"># sy</span>
                    <span class="n">scatter_source_ijk</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>  <span class="c1"># sz</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">source_to_detector_distance</span>
                    <span class="p">),</span>  <span class="c1"># sdd # TODO: if carm is not None, get this from the carm. May not work for independent source/detector movement.</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">megavol_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>  <span class="c1"># volume_shape_x</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">megavol_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>  <span class="c1"># volume_shape_y</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">megavol_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>  <span class="c1"># volume_shape_z</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">),</span>  <span class="c1"># gVolumeEdgeMinPointX</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">),</span>  <span class="c1"># gVolumeEdgeMinPointY</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">),</span>  <span class="c1"># gVolumeEdgeMinPointZ</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">megavol_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">),</span>  <span class="c1"># gVolumeEdgeMaxPointX</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">megavol_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">),</span>  <span class="c1"># gVolumeEdgeMaxPointY</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">megavol_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">),</span>  <span class="c1"># gVolumeEdgeMaxPointZ</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">megavol_spacing</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>  <span class="c1"># gVoxelElementSizeX</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">megavol_spacing</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>  <span class="c1"># gVoxelElementSizeY</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">megavol_spacing</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>  <span class="c1"># gVoxelElementSizeZ</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">index_from_world_gpu</span><span class="p">,</span>  <span class="c1"># index_from_world</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mat_mfp_structs_gpu</span><span class="p">,</span>  <span class="c1"># mat_mfp_arr</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">woodcock_struct_gpu</span><span class="p">,</span>  <span class="c1"># woodcock_mfp</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">compton_structs_gpu</span><span class="p">,</span>  <span class="c1"># compton_arr</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rayleigh_structs_gpu</span><span class="p">,</span>  <span class="c1"># rayleigh_arr</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">detector_plane_gpu</span><span class="p">,</span>  <span class="c1"># detector_plane</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">world_from_ijk_gpu</span><span class="p">,</span>  <span class="c1"># world_from_ijk</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ijk_from_world_gpu</span><span class="p">,</span>  <span class="c1"># ijk_from_world</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>  <span class="c1"># n_bins</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">energies_gpu</span><span class="p">,</span>  <span class="c1"># spectrum_energies</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cdf_gpu</span><span class="p">,</span>  <span class="c1"># spectrum_cdf</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">E_abs_keV</span><span class="p">),</span>  <span class="c1"># E_abs</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="mi">12345</span><span class="p">),</span>  <span class="c1"># seed_input</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">scatter_deposits_gpu</span><span class="p">,</span>  <span class="c1"># deposited_energy</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">num_scattered_hits_gpu</span><span class="p">,</span>  <span class="c1"># num_scattered_hits</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">num_unscattered_hits_gpu</span><span class="p">,</span>  <span class="c1"># num_unscattered_hits</span>
                <span class="p">]</span>

                <span class="c1"># same number of threads per block as the ray-casting</span>
                <span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">threads</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">threads</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

                <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Starting scatter simulation&quot;</span><span class="p">)</span>
                <span class="c1"># Call the kernel</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_scatter_blocks</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_block_index</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;running single call to scatter kernel&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">simulate_scatter</span><span class="p">(</span>
                        <span class="o">*</span><span class="n">scatter_args</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_scatter_blocks</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;running scatter kernel patchwise&quot;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span>
                        <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_scatter_blocks</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_block_index</span><span class="p">))</span>
                    <span class="p">):</span>
                        <span class="n">blocks_left_to_run</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_scatter_blocks</span> <span class="o">-</span> <span class="p">(</span>
                            <span class="n">i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_block_index</span>
                        <span class="p">)</span>
                        <span class="n">blocks_for_grid</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">blocks_left_to_run</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_block_index</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">simulate_scatter</span><span class="p">(</span>
                            <span class="o">*</span><span class="n">scatter_args</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="p">(</span><span class="n">blocks_for_grid</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="p">)</span>
                        <span class="n">context</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>

                <span class="c1"># Copy results from the GPU</span>
                <span class="n">scatter_intensity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_dtoh</span><span class="p">(</span><span class="n">scatter_intensity</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scatter_deposits_gpu</span><span class="p">)</span>
                <span class="n">scatter_intensity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">scatter_intensity</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="c1"># Here, scatter_intensity is just the recorded deposited_energy. Will need to adjust later</span>

                <span class="n">n_sc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_dtoh</span><span class="p">(</span><span class="n">n_sc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_scattered_hits_gpu</span><span class="p">)</span>
                <span class="n">n_sc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">n_sc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="n">n_pri</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_dtoh</span><span class="p">(</span><span class="n">n_pri</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_unscattered_hits_gpu</span><span class="p">)</span>
                <span class="n">n_pri</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">n_pri</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="c1"># TODO TEMP -- save the scatter outputs to .npy files</span>
                <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;scatter_intensity&quot;</span><span class="p">,</span> <span class="n">scatter_intensity</span><span class="p">)</span>
                <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;hits_scatter&quot;</span><span class="p">,</span> <span class="n">n_sc</span><span class="p">)</span>
                <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;hits_primary&quot;</span><span class="p">,</span> <span class="n">n_pri</span><span class="p">)</span>
                <span class="c1">#</span>

                <span class="c1"># Adjust scatter_img to reflect the &quot;intensity per photon&quot;. We need to account for the</span>
                <span class="c1"># fact that the pixels are not uniform in term of solid angle.</span>
                <span class="c1">#   [scatter_intensity] = [ideal deposited_energy] / [ideal number of recorded photons],</span>
                <span class="c1"># where</span>
                <span class="c1">#   [ideal number of recorded photons] = [recorded photons] * (solid_angle[pixel] / average(solid_angle))</span>
                <span class="c1"># Since [ideal deposited_energy] would be transformed the same way, we simply calculate:</span>
                <span class="c1">#   [scatter_intensity] = [recorded deposited_energy] / [recorded number of photons]</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">scatter_intensity</span><span class="p">,</span> <span class="mi">0</span> <span class="o">==</span> <span class="n">n_sc</span><span class="p">))</span>
                <span class="c1"># Since [deposited_energy] is zero whenever [num_scattered_hits] is zero, we can add 1 to</span>
                <span class="c1"># every pixel that [num_scattered_hits] is zero to avoid a &quot;divide by zero&quot; error</span>

                <span class="n">scatter_intensity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span>
                    <span class="n">scatter_intensity</span><span class="p">,</span> <span class="mi">1</span> <span class="o">*</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">n_sc</span><span class="p">)</span> <span class="o">+</span> <span class="n">n_sc</span> <span class="o">*</span> <span class="p">(</span><span class="mi">0</span> <span class="o">!=</span> <span class="n">n_sc</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="c1"># scatter_intensity now actually reflects &quot;intensity per photon&quot;</span>
                <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Finished scatter simulation, scatter_num=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">scatter_num</span><span class="si">}</span><span class="s2">. Time: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">asctime</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

                <span class="n">hits_sc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">n_sc</span><span class="p">)</span>  <span class="c1"># total number of recorded scatter hits</span>
                <span class="c1"># total number of recorded primary hits</span>
                <span class="n">hits_pri</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">n_pri</span><span class="p">)</span>

                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;hits_sc: </span><span class="si">{</span><span class="n">hits_sc</span><span class="si">}</span><span class="s2">, hits_pri: </span><span class="si">{</span><span class="n">hits_pri</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;hits_sc: </span><span class="si">{</span><span class="n">hits_sc</span><span class="si">}</span><span class="s2">, hits_pri: </span><span class="si">{</span><span class="n">hits_pri</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="n">f_sc</span> <span class="o">=</span> <span class="n">hits_sc</span> <span class="o">/</span> <span class="p">(</span><span class="n">hits_pri</span> <span class="o">+</span> <span class="n">hits_sc</span><span class="p">)</span>
                <span class="n">f_pri</span> <span class="o">=</span> <span class="n">hits_pri</span> <span class="o">/</span> <span class="p">(</span><span class="n">hits_pri</span> <span class="o">+</span> <span class="n">hits_sc</span><span class="p">)</span>

                <span class="c1">### Reasoning: prob_tot = (f_pri * prob_pri) + (f_sc * prob_sc)</span>
                <span class="c1"># such that: prob_tot / prob_pri = f_pri + f_sc * (prob_sc / prob_pri)</span>
                <span class="c1"># photon_prob *= (f_pri + f_sc * (n_sc / n_pri))</span>

                <span class="c1"># total intensity = (f_pri * intensity_pri) * (f_sc * intensity_sc)</span>
                <span class="n">intensity</span> <span class="o">=</span> <span class="p">(</span><span class="n">f_pri</span> <span class="o">*</span> <span class="n">intensity</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">f_sc</span> <span class="o">*</span> <span class="n">scatter_intensity</span><span class="p">)</span>  <span class="c1"># / f_pri</span>
            <span class="c1"># end scatter calculation</span>

            <span class="c1"># transform to collected energy in keV per cm^2 (or keV per mm^2)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">collected_energy</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solid_angle_gpu</span>
                <span class="n">solid_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_dtoh</span><span class="p">(</span><span class="n">solid_angle</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">solid_angle_gpu</span><span class="p">)</span>
                <span class="n">solid_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">solid_angle</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="c1"># TODO (mjudish): is this calculation valid? SDD is in [mm], what does f{x,y} measure?</span>
                <span class="n">pixel_size_x</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">source_to_detector_distance</span> <span class="o">/</span> <span class="n">proj</span><span class="o">.</span><span class="n">index_from_camera2d</span><span class="o">.</span><span class="n">fx</span>
                <span class="p">)</span>
                <span class="n">pixel_size_y</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">source_to_detector_distance</span> <span class="o">/</span> <span class="n">proj</span><span class="o">.</span><span class="n">index_from_camera2d</span><span class="o">.</span><span class="n">fy</span>
                <span class="p">)</span>

                <span class="c1"># get energy deposited by multiplying [intensity] with [number of photons to hit each pixel]</span>
                <span class="n">deposited_energy</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">intensity</span><span class="p">,</span> <span class="n">solid_angle</span><span class="p">)</span>
                    <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">photon_count</span>
                    <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">solid_angle</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="c1"># convert to keV / mm^2</span>
                <span class="n">deposited_energy</span> <span class="o">/=</span> <span class="n">pixel_size_x</span> <span class="o">*</span> <span class="n">pixel_size_y</span>
                <span class="n">intensities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deposited_energy</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">intensities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">intensity</span><span class="p">)</span>

            <span class="n">photon_probs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">photon_prob</span><span class="p">)</span>
        <span class="c1"># end for-loop over the projections</span>

        <span class="n">images</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">intensities</span><span class="p">)</span>
        <span class="n">photon_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">photon_probs</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Completed projection and attenuation&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_noise</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;adding Poisson noise&quot;</span><span class="p">)</span>
            <span class="n">images</span> <span class="o">=</span> <span class="n">analytic_generators</span><span class="o">.</span><span class="n">add_noise</span><span class="p">(</span>
                <span class="n">images</span><span class="p">,</span> <span class="n">photon_prob</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">photon_count</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">intensity_upper_bound</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">images</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">intensity_upper_bound</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">neglog</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;applying negative log transform&quot;</span><span class="p">)</span>
            <span class="n">images</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">neglog</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>

        <span class="c1"># Don&#39;t think this does anything.</span>
        <span class="c1"># torch.cuda.synchronize()</span>

        <span class="k">if</span> <span class="n">images</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">images</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">images</span></div>

<div class="viewcode-block" id="Projector.project_over_carm_range"><a class="viewcode-back" href="../../../deepdrr.projector.html#deepdrr.Projector.project_over_carm_range">[docs]</a>    <span class="k">def</span> <span class="nf">project_over_carm_range</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">phi_range</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">theta_range</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">degrees</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Project over a range of angles using the included CArm.</span>

<span class="sd">        Ignores the CArm&#39;s internal pose, except for its isocenter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;must provide carm device to projector&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">CArm</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;device must be a CArm&quot;</span><span class="p">)</span>

        <span class="n">camera_projections</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">phis</span><span class="p">,</span> <span class="n">thetas</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">generate_uniform_angles</span><span class="p">(</span><span class="n">phi_range</span><span class="p">,</span> <span class="n">theta_range</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">phi</span><span class="p">,</span> <span class="n">theta</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">phis</span><span class="p">,</span> <span class="n">thetas</span><span class="p">):</span>
            <span class="n">extrinsic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="o">.</span><span class="n">get_camera3d_from_world</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="o">.</span><span class="n">isocenter</span><span class="p">,</span>
                <span class="n">phi</span><span class="p">,</span>
                <span class="n">theta</span><span class="p">,</span>
                <span class="n">degrees</span><span class="o">=</span><span class="n">degrees</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">camera_projections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">geo</span><span class="o">.</span><span class="n">CameraProjection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">camera_intrinsics</span><span class="p">,</span> <span class="n">extrinsic</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="o">*</span><span class="n">camera_projections</span><span class="p">)</span></div>

<div class="viewcode-block" id="Projector.initialize_output_arrays"><a class="viewcode-back" href="../../../deepdrr.projector.html#deepdrr.Projector.initialize_output_arrays">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_output_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sensor_size</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Allocate arrays dependent on the output size. Frees previously allocated arrays.</span>

<span class="sd">        This may have to be called multiple times if the output size changes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: only allocate if the size grows. Otherwise, reuse the existing arrays.</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialized</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span> <span class="o">==</span> <span class="n">sensor_size</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialized</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">intensity_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">photon_prob_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">collected_energy</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">solid_angle_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>

        <span class="c1"># Changes the output size as well</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span> <span class="o">=</span> <span class="n">sensor_size</span>

        <span class="c1"># allocate intensity array on GPU (4 bytes to a float32)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intensity_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_size</span> <span class="o">*</span> <span class="n">NUMBYTES_FLOAT32</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;bytes alloc&#39;d for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span><span class="si">}</span><span class="s2"> self.intensity_gpu: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">output_size</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">NUMBYTES_FLOAT32</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="c1"># allocate photon_prob array on GPU (4 bytes to a float32)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">photon_prob_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_size</span> <span class="o">*</span> <span class="n">NUMBYTES_FLOAT32</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;bytes alloc&#39;d for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span><span class="si">}</span><span class="s2"> self.photon_prob_gpu: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">output_size</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">NUMBYTES_FLOAT32</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="c1"># allocate solid_angle array on GPU as needed (4 bytes to a float32)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">collected_energy</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solid_angle_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_size</span> <span class="o">*</span> <span class="n">NUMBYTES_FLOAT32</span><span class="p">)</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;bytes alloc&#39;d for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span><span class="si">}</span><span class="s2"> self.solid_angle_gpu: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">output_size</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">NUMBYTES_FLOAT32</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># NULL. Don&#39;t need to do solid angle calculation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solid_angle_gpu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="Projector.initialize"><a class="viewcode-back" href="../../../deepdrr.projector.html#deepdrr.Projector.initialize">[docs]</a>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Allocate GPU memory and transfer the volume, segmentations to GPU.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialized</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Close projector before initializing again.&quot;</span><span class="p">)</span>

        <span class="c1"># TODO: in this function, there are several instances of axis swaps.</span>
        <span class="c1"># We may want to investigate if the axis swaps are necessary.</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;beginning call to Projector.initialize&quot;</span><span class="p">)</span>
        <span class="n">init_tick</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>

        <span class="c1"># allocate and transfer the volume texture to GPU</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">volumes_gpu</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">volumes_texref</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">volume</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">):</span>
            <span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span>
            <span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">vol_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">np_to_array</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
            <span class="n">vol_texref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mod</span><span class="o">.</span><span class="n">get_texref</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;volume_</span><span class="si">{</span><span class="n">vol_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">bind_array_to_texref</span><span class="p">(</span><span class="n">vol_gpu</span><span class="p">,</span> <span class="n">vol_texref</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">volumes_gpu</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vol_gpu</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">volumes_texref</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vol_texref</span><span class="p">)</span>

        <span class="n">init_tock</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;time elapsed after intializing volumes: </span><span class="si">{</span><span class="n">init_tock</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">init_tick</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># set the interpolation mode</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">texref</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">volumes_texref</span><span class="p">:</span>
                <span class="n">texref</span><span class="o">.</span><span class="n">set_filter_mode</span><span class="p">(</span><span class="n">cuda</span><span class="o">.</span><span class="n">filter_mode</span><span class="o">.</span><span class="n">LINEAR</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span>

        <span class="c1"># List[List[segmentations]], indexing by (vol_id, material_id)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segmentations_gpu</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># List[List[texrefs]], indexing by (vol_id, material_id)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segmentations_texref</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">_vol</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">):</span>
            <span class="n">seg_for_vol</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">texref_for_vol</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">mat_id</span><span class="p">,</span> <span class="n">mat</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_materials</span><span class="p">):</span>
                <span class="n">seg</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">mat</span> <span class="ow">in</span> <span class="n">_vol</span><span class="o">.</span><span class="n">materials</span><span class="p">:</span>
                    <span class="n">seg</span> <span class="o">=</span> <span class="n">_vol</span><span class="o">.</span><span class="n">materials</span><span class="p">[</span><span class="n">mat</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">seg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">_vol</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="n">seg_for_vol</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">cuda</span><span class="o">.</span><span class="n">np_to_array</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">texref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mod</span><span class="o">.</span><span class="n">get_texref</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;seg_</span><span class="si">{</span><span class="n">vol_id</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">mat_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">texref_for_vol</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">texref</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">seg</span><span class="p">,</span> <span class="n">texref</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">seg_for_vol</span><span class="p">,</span> <span class="n">texref_for_vol</span><span class="p">):</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">bind_array_to_texref</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">texref</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
                    <span class="n">texref</span><span class="o">.</span><span class="n">set_filter_mode</span><span class="p">(</span><span class="n">cuda</span><span class="o">.</span><span class="n">filter_mode</span><span class="o">.</span><span class="n">LINEAR</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Invalid texref filter mode&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">segmentations_gpu</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_for_vol</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">segmentations_texref</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">texref</span><span class="p">)</span>

        <span class="n">init_tock</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;time elapsed after intializing segmentations: </span><span class="si">{</span><span class="n">init_tock</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">init_tick</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="c1"># allocate volumes&#39; priority level on the GPU</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">priorities_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">)</span> <span class="o">*</span> <span class="n">NUMBYTES_INT32</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">prio</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">priorities</span><span class="p">):</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod</span><span class="p">(</span>
                <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">priorities_gpu</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">NUMBYTES_INT32</span> <span class="o">*</span> <span class="n">vol_id</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">prio</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># allocate gVolumeEdge{Min,Max}Point{X,Y,Z} and gVoxelElementSize{X,Y,Z} on the GPU</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minPointX_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">)</span> <span class="o">*</span> <span class="n">NUMBYTES_FLOAT32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minPointY_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">)</span> <span class="o">*</span> <span class="n">NUMBYTES_FLOAT32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minPointZ_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">)</span> <span class="o">*</span> <span class="n">NUMBYTES_FLOAT32</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">maxPointX_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">)</span> <span class="o">*</span> <span class="n">NUMBYTES_FLOAT32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxPointY_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">)</span> <span class="o">*</span> <span class="n">NUMBYTES_FLOAT32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxPointZ_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">)</span> <span class="o">*</span> <span class="n">NUMBYTES_FLOAT32</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">voxelSizeX_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">)</span> <span class="o">*</span> <span class="n">NUMBYTES_FLOAT32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">voxelSizeY_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">)</span> <span class="o">*</span> <span class="n">NUMBYTES_FLOAT32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">voxelSizeZ_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">)</span> <span class="o">*</span> <span class="n">NUMBYTES_FLOAT32</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_vol</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">):</span>
            <span class="n">gpu_ptr_offset</span> <span class="o">=</span> <span class="n">NUMBYTES_FLOAT32</span> <span class="o">*</span> <span class="n">i</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minPointX_gpu</span><span class="p">)</span> <span class="o">+</span> <span class="n">gpu_ptr_offset</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">))</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minPointY_gpu</span><span class="p">)</span> <span class="o">+</span> <span class="n">gpu_ptr_offset</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">))</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minPointZ_gpu</span><span class="p">)</span> <span class="o">+</span> <span class="n">gpu_ptr_offset</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">))</span>

            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod</span><span class="p">(</span>
                <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxPointX_gpu</span><span class="p">)</span> <span class="o">+</span> <span class="n">gpu_ptr_offset</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">_vol</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod</span><span class="p">(</span>
                <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxPointY_gpu</span><span class="p">)</span> <span class="o">+</span> <span class="n">gpu_ptr_offset</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">_vol</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod</span><span class="p">(</span>
                <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxPointZ_gpu</span><span class="p">)</span> <span class="o">+</span> <span class="n">gpu_ptr_offset</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">_vol</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod</span><span class="p">(</span>
                <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">voxelSizeX_gpu</span><span class="p">)</span> <span class="o">+</span> <span class="n">gpu_ptr_offset</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">_vol</span><span class="o">.</span><span class="n">spacing</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="p">)</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod</span><span class="p">(</span>
                <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">voxelSizeY_gpu</span><span class="p">)</span> <span class="o">+</span> <span class="n">gpu_ptr_offset</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">_vol</span><span class="o">.</span><span class="n">spacing</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
            <span class="p">)</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod</span><span class="p">(</span>
                <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">voxelSizeZ_gpu</span><span class="p">)</span> <span class="o">+</span> <span class="n">gpu_ptr_offset</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">_vol</span><span class="o">.</span><span class="n">spacing</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
            <span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;gVolume information allocated and copied to GPU&quot;</span><span class="p">)</span>

        <span class="c1"># allocate source coord.s on GPU (4 bytes for each of {x,y,z} for each volume)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sourceX_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">)</span> <span class="o">*</span> <span class="n">NUMBYTES_FLOAT32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sourceY_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">)</span> <span class="o">*</span> <span class="n">NUMBYTES_FLOAT32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sourceZ_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">)</span> <span class="o">*</span> <span class="n">NUMBYTES_FLOAT32</span><span class="p">)</span>

        <span class="n">init_tock</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;time elapsed after intializing multivolume stuff: </span><span class="si">{</span><span class="n">init_tock</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">init_tick</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="c1"># allocate world_from_index matrix array on GPU (3x3 array x 4 bytes per float32)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">world_from_index_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">NUMBYTES_FLOAT32</span><span class="p">)</span>

        <span class="c1"># allocate ijk_from_world for each volume.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ijk_from_world_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">NUMBYTES_FLOAT32</span>
        <span class="p">)</span>

        <span class="c1"># Initializes the output_shape as well.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize_output_arrays</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">camera_intrinsics</span><span class="o">.</span><span class="n">sensor_size</span><span class="p">)</span>

        <span class="c1"># allocate and transfer spectrum energies (4 bytes to a float32)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="n">noncont_energies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="o">/</span> <span class="mi">1000</span>
        <span class="n">contiguous_energies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">noncont_energies</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">n_bins</span> <span class="o">=</span> <span class="n">contiguous_energies</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">energies_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="n">n_bins</span> <span class="o">*</span> <span class="n">NUMBYTES_FLOAT32</span><span class="p">)</span>
        <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">energies_gpu</span><span class="p">,</span> <span class="n">contiguous_energies</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;bytes alloc&#39;d for self.energies_gpu: </span><span class="si">{</span><span class="n">n_bins</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">NUMBYTES_FLOAT32</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># allocate and transfer spectrum pdf (4 bytes to a float32)</span>
        <span class="n">noncont_pdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">contiguous_pdf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">noncont_pdf</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">contiguous_pdf</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">contiguous_energies</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">assert</span> <span class="n">contiguous_pdf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">n_bins</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pdf_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="n">n_bins</span> <span class="o">*</span> <span class="n">NUMBYTES_FLOAT32</span><span class="p">)</span>
        <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_gpu</span><span class="p">,</span> <span class="n">contiguous_pdf</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;bytes alloc&#39;d for self.pdf_gpu </span><span class="si">{</span><span class="n">n_bins</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">NUMBYTES_FLOAT32</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># precompute, allocate, and transfer the get_absorption_coef(energy, material) table (4 bytes to a float32)</span>
        <span class="n">absorption_coef_table</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_bins</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_materials</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="nb">bin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_bins</span><span class="p">):</span>  <span class="c1"># , energy in enumerate(energies):</span>
            <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">mat_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_materials</span><span class="p">):</span>
                <span class="n">absorption_coef_table</span><span class="p">[</span>
                    <span class="nb">bin</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_materials</span><span class="p">)</span> <span class="o">+</span> <span class="n">m</span>
                <span class="p">]</span> <span class="o">=</span> <span class="n">mass_attenuation</span><span class="o">.</span><span class="n">get_absorption_coefs</span><span class="p">(</span>
                    <span class="n">contiguous_energies</span><span class="p">[</span><span class="nb">bin</span><span class="p">],</span> <span class="n">mat_name</span>
                <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">absorption_coef_table_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
            <span class="n">n_bins</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_materials</span><span class="p">)</span> <span class="o">*</span> <span class="n">NUMBYTES_FLOAT32</span>
        <span class="p">)</span>
        <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">absorption_coef_table_gpu</span><span class="p">,</span> <span class="n">absorption_coef_table</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;size alloc&#39;d for self.absorption_coef_table_gpu: </span><span class="si">{</span><span class="n">n_bins</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_materials</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">NUMBYTES_FLOAT32</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="n">init_tock</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;time elapsed after intializing rest of primary-signal stuff: </span><span class="si">{</span><span class="n">init_tock</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">init_tick</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Scatter-specific initializations</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scatter_num</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;beginning scatter resampling&quot;</span><span class="p">)</span>
                <span class="c1"># Combine the multiple volumes into one single volume</span>
                <span class="n">x_points_world</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">y_points_world</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">z_points_world</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">for</span> <span class="n">_vol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">:</span>
                    <span class="n">corners_ijk</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">geo</span><span class="o">.</span><span class="n">point</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">),</span>
                        <span class="n">geo</span><span class="o">.</span><span class="n">point</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">_vol</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">),</span>
                        <span class="n">geo</span><span class="o">.</span><span class="n">point</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">_vol</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">),</span>
                        <span class="n">geo</span><span class="o">.</span><span class="n">point</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">_vol</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">_vol</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">),</span>
                        <span class="n">geo</span><span class="o">.</span><span class="n">point</span><span class="p">(</span><span class="n">_vol</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">),</span>
                        <span class="n">geo</span><span class="o">.</span><span class="n">point</span><span class="p">(</span><span class="n">_vol</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">_vol</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">),</span>
                        <span class="n">geo</span><span class="o">.</span><span class="n">point</span><span class="p">(</span><span class="n">_vol</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">_vol</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">),</span>
                        <span class="n">geo</span><span class="o">.</span><span class="n">point</span><span class="p">(</span>
                            <span class="n">_vol</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span>
                            <span class="n">_vol</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span>
                            <span class="n">_vol</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span>
                        <span class="p">),</span>
                    <span class="p">]</span>

                    <span class="k">for</span> <span class="n">ijk</span> <span class="ow">in</span> <span class="n">corners_ijk</span><span class="p">:</span>
                        <span class="n">corner</span> <span class="o">=</span> <span class="n">_vol</span><span class="o">.</span><span class="n">world_from_ijk</span> <span class="o">@</span> <span class="n">ijk</span>
                        <span class="n">x_points_world</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">corner</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">y_points_world</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">corner</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                        <span class="n">z_points_world</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">corner</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

                <span class="c1"># The points that define the bounding box of the combined volume</span>
                <span class="n">min_world_point</span> <span class="o">=</span> <span class="n">geo</span><span class="o">.</span><span class="n">point</span><span class="p">(</span>
                    <span class="nb">min</span><span class="p">(</span><span class="n">x_points_world</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">y_points_world</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">z_points_world</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">max_world_point</span> <span class="o">=</span> <span class="n">geo</span><span class="o">.</span><span class="n">point</span><span class="p">(</span>
                    <span class="nb">max</span><span class="p">(</span><span class="n">x_points_world</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">y_points_world</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">z_points_world</span><span class="p">)</span>
                <span class="p">)</span>

                <span class="c1"># TODO: make this calculation more numpy-style</span>
                <span class="n">largest_spacing_x</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">_vol</span><span class="o">.</span><span class="n">spacing</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">_vol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">])</span>
                <span class="n">largest_spacing_y</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">_vol</span><span class="o">.</span><span class="n">spacing</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">_vol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">])</span>
                <span class="n">largest_spacing_z</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">_vol</span><span class="o">.</span><span class="n">spacing</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">_vol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">])</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">megavol_spacing</span> <span class="o">=</span> <span class="n">geo</span><span class="o">.</span><span class="n">vector</span><span class="p">(</span>
                    <span class="n">largest_spacing_x</span><span class="p">,</span> <span class="n">largest_spacing_y</span><span class="p">,</span> <span class="n">largest_spacing_z</span>
                <span class="p">)</span>

                <span class="c1"># readjust the bounding box so that the voxels fit evenly</span>
                <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                    <span class="n">remainder</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">max_world_point</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="n">min_world_point</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
                    <span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">megavol_spacing</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">remainder</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">max_world_point</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">max_world_point</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
                            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">megavol_spacing</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
                            <span class="o">-</span> <span class="n">remainder</span>
                        <span class="p">)</span>

                <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;megavol spacing: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">megavol_spacing</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="n">mega_x_len</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
                    <span class="mf">0.01</span>
                    <span class="o">+</span> <span class="p">(</span>
                        <span class="p">(</span><span class="n">max_world_point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">min_world_point</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">megavol_spacing</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">mega_y_len</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
                    <span class="mf">0.01</span>
                    <span class="o">+</span> <span class="p">(</span>
                        <span class="p">(</span><span class="n">max_world_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">min_world_point</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                        <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">megavol_spacing</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">mega_z_len</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
                    <span class="mf">0.01</span>
                    <span class="o">+</span> <span class="p">(</span>
                        <span class="p">(</span><span class="n">max_world_point</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">min_world_point</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                        <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">megavol_spacing</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">megavol_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">mega_x_len</span><span class="p">,</span> <span class="n">mega_y_len</span><span class="p">,</span> <span class="n">mega_z_len</span><span class="p">)</span>

                <span class="c1"># megavol.world_from_ijk == megavol.world_from_anatomical @ megavol.anatomical_from_ijk</span>
                <span class="c1"># We assume that megavol.world_from_anatomical is the identity transform</span>
                <span class="c1"># We assume that the origin for the maegvol is voxel (0,0,0)</span>
                <span class="c1"># Reference the Volume class for calculation of anatomical_from_ijk</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;TODO: check from_scaling is correct&quot;</span><span class="p">)</span>

                <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
                <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">megavol_spacing</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">megavol_spacing</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">megavol_spacing</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">megavol_world_from_ijk</span> <span class="o">=</span> <span class="n">geo</span><span class="o">.</span><span class="n">FrameTransform</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">megavol_ijk_from_world</span> <span class="o">=</span> <span class="n">megavol_world_from_ijk</span><span class="o">.</span><span class="n">inv</span>

                <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;max_world_point: </span><span class="si">{</span><span class="n">max_world_point</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;min_world_point: </span><span class="si">{</span><span class="n">min_world_point</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;mega_[x,y,z]_len: (</span><span class="si">{</span><span class="n">mega_x_len</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">mega_y_len</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">mega_z_len</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="p">)</span>

                <span class="c1"># allocate megavolume data and labeled (i.e., not binary) segmentation</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">megavol_density_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
                    <span class="n">NUMBYTES_FLOAT32</span> <span class="o">*</span> <span class="n">mega_x_len</span> <span class="o">*</span> <span class="n">mega_y_len</span> <span class="o">*</span> <span class="n">mega_z_len</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">megavol_labeled_seg_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
                    <span class="n">NUMBYTES_INT8</span> <span class="o">*</span> <span class="n">mega_x_len</span> <span class="o">*</span> <span class="n">mega_y_len</span> <span class="o">*</span> <span class="n">mega_z_len</span>
                <span class="p">)</span>

                <span class="c1"># TODO: discuss whether it is stylistically fine that these are allocated</span>
                <span class="c1"># and freed entirely within the Projector.initialized function</span>
                <span class="n">inp_priority_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="n">NUMBYTES_INT32</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">))</span>
                <span class="n">inp_voxelBoundX_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="n">NUMBYTES_INT32</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">))</span>
                <span class="n">inp_voxelBoundY_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="n">NUMBYTES_INT32</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">))</span>
                <span class="n">inp_voxelBoundZ_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="n">NUMBYTES_INT32</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">))</span>
                <span class="n">inp_ijk_from_world_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
                    <span class="n">NUMBYTES_INT32</span>
                    <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ijk_from_world</span><span class="p">)</span><span class="o">.</span><span class="n">size</span>
                    <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">)</span>
                <span class="p">)</span>

                <span class="k">for</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">_vol</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">):</span>
                    <span class="n">int_offset</span> <span class="o">=</span> <span class="n">NUMBYTES_INT32</span> <span class="o">*</span> <span class="n">vol_id</span>
                    <span class="n">arr_offset</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">NUMBYTES_INT32</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">_vol</span><span class="o">.</span><span class="n">ijk_from_world</span><span class="p">)</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">vol_id</span>
                    <span class="p">)</span>
                    <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod</span><span class="p">(</span>
                        <span class="nb">int</span><span class="p">(</span><span class="n">inp_priority_gpu</span><span class="p">)</span> <span class="o">+</span> <span class="n">int_offset</span><span class="p">,</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">priorities</span><span class="p">[</span><span class="n">vol_id</span><span class="p">]),</span>
                    <span class="p">)</span>
                    <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod</span><span class="p">(</span>
                        <span class="nb">int</span><span class="p">(</span><span class="n">inp_voxelBoundX_gpu</span><span class="p">)</span> <span class="o">+</span> <span class="n">int_offset</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">_vol</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="p">)</span>
                    <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod</span><span class="p">(</span>
                        <span class="nb">int</span><span class="p">(</span><span class="n">inp_voxelBoundY_gpu</span><span class="p">)</span> <span class="o">+</span> <span class="n">int_offset</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">_vol</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="p">)</span>
                    <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod</span><span class="p">(</span>
                        <span class="nb">int</span><span class="p">(</span><span class="n">inp_voxelBoundZ_gpu</span><span class="p">)</span> <span class="o">+</span> <span class="n">int_offset</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">_vol</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                    <span class="p">)</span>
                    <span class="n">inp_ijk_from_world</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">_vol</span><span class="o">.</span><span class="n">ijk_from_world</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">inp_ijk_from_world</span><span class="p">)</span>
                    <span class="c1"># cuda.memcpy_htod(int(inp_ijk_from_world_gpu) + arr_offset, inp_ijk_from_world)</span>
                    <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod</span><span class="p">(</span>
                        <span class="nb">int</span><span class="p">(</span><span class="n">inp_ijk_from_world_gpu</span><span class="p">)</span> <span class="o">+</span> <span class="n">arr_offset</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="mi">12345</span><span class="p">)</span>
                    <span class="p">)</span>

                <span class="c1"># call the resampling kernel</span>
                <span class="c1"># TODO: null segmentation should be assigned AIR material</span>
                <span class="c1"># will need to figure out how to handle the case when AIR</span>
                <span class="c1"># is not in self.all_materials</span>
                <span class="n">resampling_args</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">inp_priority_gpu</span><span class="p">,</span>
                    <span class="n">inp_voxelBoundX_gpu</span><span class="p">,</span>
                    <span class="n">inp_voxelBoundY_gpu</span><span class="p">,</span>
                    <span class="n">inp_voxelBoundZ_gpu</span><span class="p">,</span>
                    <span class="n">inp_ijk_from_world_gpu</span><span class="p">,</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">min_world_point</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>  <span class="c1"># mega{Min,Max}{X,Y,Z}</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">min_world_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">min_world_point</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">max_world_point</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">max_world_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">max_world_point</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">megavol_spacing</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>  <span class="c1"># megaVoxelSize{X,Y,Z}</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">megavol_spacing</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">megavol_spacing</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">mega_x_len</span><span class="p">),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">mega_y_len</span><span class="p">),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">mega_z_len</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">megavol_density_gpu</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">megavol_labeled_seg_gpu</span><span class="p">,</span>
                <span class="p">]</span>

                <span class="n">init_tock</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;resampling kernel args set. time elapsed: </span><span class="si">{</span><span class="n">init_tock</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">init_tick</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

                <span class="c1"># Calculate block and grid sizes: each block is a 4x4x4 cube of voxels</span>
                <span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">blocks_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">mega_x_len</span> <span class="o">/</span> <span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="n">blocks_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">mega_y_len</span> <span class="o">/</span> <span class="n">block</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">blocks_z</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">mega_z_len</span> <span class="o">/</span> <span class="n">block</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
                <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Resampling: </span><span class="si">{</span><span class="n">blocks_x</span><span class="si">}</span><span class="s2">x</span><span class="si">{</span><span class="n">blocks_y</span><span class="si">}</span><span class="s2">x</span><span class="si">{</span><span class="n">blocks_z</span><span class="si">}</span><span class="s2"> blocks with </span><span class="si">{</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">x</span><span class="si">{</span><span class="n">block</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">x</span><span class="si">{</span><span class="n">block</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2"> threads each&quot;</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">blocks_x</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_block_index</span>
                    <span class="ow">and</span> <span class="n">blocks_y</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_block_index</span>
                    <span class="ow">and</span> <span class="n">blocks_z</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_block_index</span>
                <span class="p">):</span>
                    <span class="n">offset_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">offset_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">offset_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">resample_megavolume</span><span class="p">(</span>
                        <span class="o">*</span><span class="n">resampling_args</span><span class="p">,</span>
                        <span class="n">offset_x</span><span class="p">,</span>
                        <span class="n">offset_y</span><span class="p">,</span>
                        <span class="n">offset_z</span><span class="p">,</span>
                        <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
                        <span class="n">grid</span><span class="o">=</span><span class="p">(</span><span class="n">blocks_x</span><span class="p">,</span> <span class="n">blocks_y</span><span class="p">,</span> <span class="n">blocks_z</span><span class="p">),</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Running resampling kernel patchwise&quot;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="n">blocks_x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_block_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
                        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="n">blocks_y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_block_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
                            <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span>
                                <span class="p">(</span><span class="n">blocks_z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_block_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                            <span class="p">):</span>
                                <span class="n">offset_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_block_index</span><span class="p">)</span>
                                <span class="n">offset_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">y</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_block_index</span><span class="p">)</span>
                                <span class="n">offset_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">z</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_block_index</span><span class="p">)</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">resample_megavolume</span><span class="p">(</span>
                                    <span class="o">*</span><span class="n">resampling_args</span><span class="p">,</span>
                                    <span class="n">offset_x</span><span class="p">,</span>
                                    <span class="n">offset_y</span><span class="p">,</span>
                                    <span class="n">offset_z</span><span class="p">,</span>
                                    <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
                                    <span class="n">grid</span><span class="o">=</span><span class="p">(</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">max_block_index</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">max_block_index</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">max_block_index</span><span class="p">,</span>
                                    <span class="p">),</span>
                                <span class="p">)</span>
                                <span class="n">context</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>

                <span class="n">inp_priority_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>
                <span class="n">inp_voxelBoundX_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>
                <span class="n">inp_voxelBoundY_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>
                <span class="n">inp_voxelBoundZ_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>
                <span class="n">inp_ijk_from_world_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>

                <span class="n">init_tock</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;time elapsed after call to resampling kernel: </span><span class="si">{</span><span class="n">init_tock</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">init_tick</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">megavol_ijk_from_world</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ijk_from_world</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;self.volumes[0].ijk_from_world dim:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ijk_from_world</span><span class="o">.</span><span class="n">dim</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ijk_from_world</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">megavol_spacing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">spacing</span>

                <span class="n">mega_x_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">mega_y_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">mega_z_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">num_voxels</span> <span class="o">=</span> <span class="n">mega_x_len</span> <span class="o">*</span> <span class="n">mega_y_len</span> <span class="o">*</span> <span class="n">mega_z_len</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">megavol_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">mega_x_len</span><span class="p">,</span> <span class="n">mega_y_len</span><span class="p">,</span> <span class="n">mega_z_len</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">megavol_density_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="n">NUMBYTES_FLOAT32</span> <span class="o">*</span> <span class="n">num_voxels</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">megavol_labeled_seg_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
                    <span class="n">NUMBYTES_INT8</span> <span class="o">*</span> <span class="n">num_voxels</span>
                <span class="p">)</span>

                <span class="c1"># TODO: null_seg should be assigned to AIR material.</span>
                <span class="c1"># will need to figure out how to handle the case where</span>
                <span class="c1"># AIR material was not originally in self.all_materials</span>

                <span class="c1"># copy over from self.volumes[0] to the gpu</span>
                <span class="n">labeled_seg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
                <span class="n">null_seg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mat</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_materials</span><span class="p">):</span>
                    <span class="n">labeled_seg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
                        <span class="n">labeled_seg</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">materials</span><span class="p">[</span><span class="n">mat</span><span class="p">]</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
                    <span class="n">null_seg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                        <span class="n">null_seg</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">materials</span><span class="p">[</span><span class="n">mat</span><span class="p">])</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
                <span class="c1"># a labeled_seg value of NUM_MATERIALS indicates a null segmentation</span>
                <span class="n">labeled_seg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
                    <span class="n">labeled_seg</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_materials</span><span class="p">)</span> <span class="o">*</span> <span class="n">null_seg</span>
                <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
                <span class="c1"># NOTE: axis swap not necessary because using raw array, not texture</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">megavol_labeled_seg_gpu</span><span class="p">,</span> <span class="n">labeled_seg</span><span class="p">)</span>

                <span class="c1"># Copy volume density info to self.megavol_density_gpu</span>
                <span class="c1"># NOTE: axis swap not necessary because using raw array, not texture</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">megavol_density_gpu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

                <span class="n">init_tock</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;time elapsed after copying megavolume to GPU: </span><span class="si">{</span><span class="n">init_tock</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">init_tick</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="c1"># end initialization of megavolume</span>

            <span class="c1"># Material MFP structs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mat_mfp_struct_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mat_mfp_structs_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_materials</span><span class="p">)</span> <span class="o">*</span> <span class="n">CudaMatMfpStruct</span><span class="o">.</span><span class="n">MEMSIZE</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mat</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_materials</span><span class="p">):</span>
                <span class="n">struct_gpu_ptr</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mat_mfp_structs_gpu</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span>
                    <span class="n">i</span> <span class="o">*</span> <span class="n">CudaMatMfpStruct</span><span class="o">.</span><span class="n">MEMSIZE</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mat_mfp_struct_dict</span><span class="p">[</span><span class="n">mat</span><span class="p">]</span> <span class="o">=</span> <span class="n">CudaMatMfpStruct</span><span class="p">(</span>
                    <span class="n">MFP_DATA</span><span class="p">[</span><span class="n">mat</span><span class="p">],</span> <span class="n">struct_gpu_ptr</span>
                <span class="p">)</span>

            <span class="n">init_tock</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;time elapsed after intializing MFP structs: </span><span class="si">{</span><span class="n">init_tock</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">init_tick</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

            <span class="c1"># Woodcock MFP struct</span>
            <span class="n">wc_np_arr</span> <span class="o">=</span> <span class="n">scatter</span><span class="o">.</span><span class="n">make_woodcock_mfp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_materials</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">woodcock_struct_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="n">CudaWoodcockStruct</span><span class="o">.</span><span class="n">MEMSIZE</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">woodcock_struct</span> <span class="o">=</span> <span class="n">CudaWoodcockStruct</span><span class="p">(</span>
                <span class="n">wc_np_arr</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">woodcock_struct_gpu</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="n">init_tock</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;time elapsed after intializing Woodcock struct: </span><span class="si">{</span><span class="n">init_tock</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">init_tick</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

            <span class="c1"># Material Compton structs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compton_struct_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compton_structs_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_materials</span><span class="p">)</span> <span class="o">*</span> <span class="n">CudaComptonStruct</span><span class="o">.</span><span class="n">MEMSIZE</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mat</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_materials</span><span class="p">):</span>
                <span class="n">struct_gpu_ptr</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compton_structs_gpu</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span>
                    <span class="n">i</span> <span class="o">*</span> <span class="n">CudaComptonStruct</span><span class="o">.</span><span class="n">MEMSIZE</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">compton_struct_dict</span><span class="p">[</span><span class="n">mat</span><span class="p">]</span> <span class="o">=</span> <span class="n">CudaComptonStruct</span><span class="p">(</span>
                    <span class="n">COMPTON_DATA</span><span class="p">[</span><span class="n">mat</span><span class="p">],</span> <span class="n">struct_gpu_ptr</span>
                <span class="p">)</span>

            <span class="n">init_tock</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;time elapsed after intializing Compton structs: </span><span class="si">{</span><span class="n">init_tock</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">init_tick</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

            <span class="c1"># Material Rayleigh structs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rayleigh_struct_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rayleigh_structs_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_materials</span><span class="p">)</span> <span class="o">*</span> <span class="n">CudaRayleighStruct</span><span class="o">.</span><span class="n">MEMSIZE</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mat</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_materials</span><span class="p">):</span>
                <span class="n">struct_gpu_ptr</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rayleigh_structs_gpu</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span>
                    <span class="n">i</span> <span class="o">*</span> <span class="n">CudaRayleighStruct</span><span class="o">.</span><span class="n">MEMSIZE</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rayleigh_struct_dict</span><span class="p">[</span><span class="n">mat</span><span class="p">]</span> <span class="o">=</span> <span class="n">CudaRayleighStruct</span><span class="p">(</span>
                    <span class="n">rita_samplers</span><span class="p">[</span><span class="n">mat</span><span class="p">],</span> <span class="n">mat</span><span class="p">,</span> <span class="n">struct_gpu_ptr</span>
                <span class="p">)</span>

            <span class="n">init_tock</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;time elapsed after intializing RITA structs: </span><span class="si">{</span><span class="n">init_tock</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">init_tick</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

            <span class="c1"># Detector plane</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">detector_plane_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="n">CudaPlaneSurfaceStruct</span><span class="o">.</span><span class="n">MEMSIZE</span><span class="p">)</span>

            <span class="c1"># world_from_ijk</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">world_from_ijk_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">NUMBYTES_FLOAT32</span><span class="p">)</span>

            <span class="c1"># index_from_world</span>
            <span class="c1"># TODO: get the factor of &quot;2 x 4&quot; from a more abstract source</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">index_from_world_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
                <span class="mi">2</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">NUMBYTES_FLOAT32</span>
            <span class="p">)</span>  <span class="c1"># (2, 4) array of floats</span>

            <span class="c1"># spectrum cdf</span>
            <span class="n">n_bins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># spectrum_cdf = np.array([np.sum(self.spectrum[0:i+1, 1]) for i in range(n_bins)])</span>
            <span class="c1"># spectrum_cdf = (spectrum_cdf / np.sum(self.spectrum[:, 1])).astype(np.float32)</span>
            <span class="n">spectrum_cdf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">contiguous_pdf</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_bins</span><span class="p">)]</span>
            <span class="p">)</span>
            <span class="c1"># log.debug(f&quot;spectrum CDF:\n{spectrum_cdf}&quot;)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cdf_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="n">n_bins</span> <span class="o">*</span> <span class="n">NUMBYTES_FLOAT32</span><span class="p">)</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cdf_gpu</span><span class="p">,</span> <span class="n">spectrum_cdf</span><span class="p">)</span>

            <span class="c1"># output</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scatter_deposits_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">output_size</span> <span class="o">*</span> <span class="n">NUMBYTES_FLOAT32</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_scattered_hits_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">output_size</span> <span class="o">*</span> <span class="n">NUMBYTES_INT32</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_unscattered_hits_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">output_size</span> <span class="o">*</span> <span class="n">NUMBYTES_INT32</span>
            <span class="p">)</span>

        <span class="n">init_tock</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;time elapsed after intializing rest of stuff: </span><span class="si">{</span><span class="n">init_tock</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">init_tick</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Mark self as initialized.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialized</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Projector.free"><a class="viewcode-back" href="../../../deepdrr.projector.html#deepdrr.Projector.free">[docs]</a>    <span class="k">def</span> <span class="nf">free</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Free the allocated GPU memory.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialized</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">vol_gpu</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes_gpu</span><span class="p">):</span>
                <span class="n">vol_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">segmentations_gpu</span><span class="p">[</span><span class="n">vol_id</span><span class="p">]:</span>
                    <span class="n">seg</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">priorities_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">minPointX_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">minPointY_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">minPointZ_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">maxPointX_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maxPointY_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maxPointZ_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">voxelSizeX_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">voxelSizeY_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">voxelSizeZ_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">sourceX_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sourceY_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sourceZ_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">world_from_index_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ijk_from_world_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">intensity_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">photon_prob_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">collected_energy</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">solid_angle_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">energies_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pdf_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">absorption_coef_table_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scatter_num</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">megavol_density_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">megavol_labeled_seg_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mat_mfp_structs_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">woodcock_struct_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">compton_structs_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rayleigh_structs_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">detector_plane_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">index_from_world_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cdf_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scatter_deposits_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_scattered_hits_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_unscattered_hits_gpu</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">initialized</span> <span class="o">=</span> <span class="kc">False</span></div>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Benjamin D. Killeen, Cong Gao, Jan-Nico Zaech, and Mathias Unberath.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>